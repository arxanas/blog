<!DOCTYPE html>
<html lang="pl">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
    <title>Kodowanie w Rust modułów w stylu ML</title>
  
  <meta name="author" content="Waleed Khan">
  <meta name="description" content="            Docelowi odbiorcy              Programiści OCaml/SML uczący się języka Rust.        Programiści funkcjonalni, którzy wcześniej nie mieli stycznoś...">

  <link rel="stylesheet" href="/pl/css/main.css">
  <link rel="canonical" href="https://blog.waleedkhan.name/pl/kodowanie-w-rust-modułów-w-stylu-ml/">
  <link rel="alternate" type="application/rss+xml" title="Steno & PL" href="https://blog.waleedkhan.name/pl/feed.xml">
  <script src="//instant.page/5.1.0" type="module" integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
  

  <link rel="me" href="https://github.com/arxanas">
  <link rel="me" href="https://twitter.com/arxanas">
  <link rel="me" href="mailto:me@waleedkhan.name">

  
  

  <!-- See https://indieweb.org/webmention.io -->
  <link rel="webmention" href="https://webmention.io/blog.waleedkhan.name/webmention" />
  <link rel="pingback" href="https://webmention.io/webmention?forward=https://blog.waleedkhan.name/webmention" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/pl/">Steno & PL</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          <a class="page-link" href="/pl/o-mnie/">O mnie</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Kodowanie w Rust modułów w stylu ML</h1>
    <p class="post-meta"><time datetime="2023-06-17T00:00:00+00:00" itemprop="datePublished">Jun 17, 2023</time>
    
      <span class="post-meta">
        <br />
        
        <a href="/encoding-ml-style-modules-in-rust/">Read in English 🇺🇸</a>
        
      </span>
    
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
    <div class="publication-notes">
  <table>
    <tr>
      <td>Docelowi odbiorcy</td>
      <td><ul>
        <li>Programiści OCaml/SML uczący się języka Rust.</li>
        <li>Programiści funkcjonalni, którzy wcześniej nie mieli styczności z języków takimi jak OCaml czy Haskell, ale mogą być zainteresowani pewną techniką abstrakcji.</li>
        <ul><li>
        Należy zauważyć, że termin “moduł w stylu ML” odnosi się do <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">rodziny języków programowania ML</a>, a nie do <a href="https://pl.wikipedia.org/wiki/Uczenie_maszynowe">uczenia maszynowego</a>.
        </li></ul>
      </ul>
      </td>
    </tr>
    <tr>
      <td>Pochodzenie</td>
      <td><ul>
        <li>Doświadczenie w OCaml i Rust.</li>
        <li>Doświadczenie w teorii typów.</li>
      </ul></td>
    </tr>
    <tr>
      <td>Nastrój</td>
      <td>Pomocny</td>
    </tr>
    
<tr>
  <td>Język</td>
  <td>Obcy. Moim pierwszym język jest angielki. Jeśli zobaczysz błąd, niezależnie od tego, czy chodzi o pisownię, gramatykę czy dobór słow, skomentuj to!</td>
</tr>


  </table>
</div>

<div class="series-and-toc">

  <p class="toc-header">Spis treści:</p>

<ul id="markdown-toc">
  <li><a href="#stwierdzenie-problemu" id="markdown-toc-stwierdzenie-problemu">Stwierdzenie problemu</a></li>
  <li><a href="#cachowanie-funkcji" id="markdown-toc-cachowanie-funkcji">Cachowanie funkcji</a>    <ul>
      <li><a href="#cachowanie-indywidualnej-funkcji" id="markdown-toc-cachowanie-indywidualnej-funkcji">Cachowanie indywidualnej funkcji</a></li>
      <li><a href="#cachowanie-funkcji-generyczne" id="markdown-toc-cachowanie-funkcji-generyczne">Cachowanie funkcji generyczne</a></li>
      <li><a href="#uważanie-funkcji-jako-wartość" id="markdown-toc-uważanie-funkcji-jako-wartość">Uważanie funkcji jako wartość</a></li>
    </ul>
  </li>
  <li><a href="#kodowanie-modułów" id="markdown-toc-kodowanie-modułów">Kodowanie modułów</a>    <ul>
      <li><a href="#moduły-w-ocaml" id="markdown-toc-moduły-w-ocaml">Moduły w OCaml</a></li>
      <li><a href="#associated-typy" id="markdown-toc-associated-typy">“Associated” typy</a></li>
      <li><a href="#parametryzowanie-tylko-nad-typami" id="markdown-toc-parametryzowanie-tylko-nad-typami">Parametryzowanie tylko nad typami</a></li>
      <li><a href="#inne-kodowania" id="markdown-toc-inne-kodowania">Inne kodowania</a></li>
    </ul>
  </li>
  <li><a href="#powiązane-posty" id="markdown-toc-powiązane-posty">Powiązane posty</a></li>
  <li><a href="#komentarze" id="markdown-toc-komentarze">Komentarze</a></li>
</ul>

</div>

<h2 id="stwierdzenie-problemu">Stwierdzenie problemu</h2>

<p>Problem: chcesz dodać do istniejącego typu implementującego pewnego trait nową działalność, która będzie wymagała używania wewnętrznego stanu.</p>

<p>Problem: chcesz wziąć istniejący typ spełniający jakąś cechę i rozszerzyć go o nową funkcjonalność — w tym nowy stan wewnętrzny.</p>

<p>Jeśli nie chcesz dodać wewnętrznego stanu, istnieje kilka możliwych rozwiązań:</p>

<ul>
  <li>Używać domyślnych implementacji metod trait.</li>
  <li>Używać “extension traits”.</li>
  <li>Używać <code class="language-plaintext highlighter-rouge">impl dyn</code> <em>(uwaga techniczna: będzie to wymagać dynamicznego wywoływania na czasie wykonywania)</em>.</li>
  <li>Używać wolnych (globalnych) funkcji, które są generyczne i akceptują dowolny typ implementujący trait.</li>
</ul>

<p>Na przykład: implementowanie warstwa cachowania [ang. “caching”] tylko <em>raz</em>, które mogło wtedy zastosować się do <em>dowolnej</em> implementacji jakiegoś trait <code class="language-plaintext highlighter-rouge">Backend</code>.</p>

<p>Moduły w stylu ML są naturalnym rozwiązaniem dla tego rodzaju problemów. Bardziej wydajne są one niż tradycyjne “moduły”, jak uważa się w popularnych językach programowania. Zarówno moduły w stylu ML, jak i tradycyjne moduły obsługują:</p>

<ul>
  <li>Rozdzielanie kodu na logiczne przestrzenie nazw [ang. “namespaces”].</li>
  <li>Definiowanie interfejsów.</li>
  <li>Abstrahowanie typów danych i ukrywanie szczegółów implementacji.</li>
</ul>

<p>Ponadto moduły w stylu ML mogą być parametryzowane na <em>typach</em> (podobnie szablonom [ang. “templates”] lub typom generycznym w innych językach programowania), a także _innych modułach _(omówione w tym artykule).</p>

<p>Pomimo, że Rust pochodzi z OCaml, nie dziedziczy systemu modułów w stylu ML. Zamiast, system “trait” w Rust przypomina <a href="https://en.wikipedia.org/wiki/Type_class">typeclasses z Haskell</a>. Jednak, korzystający dodatkowych funkcji, możemy symulować w Rust moduły w stylu ML.</p>

<p><em>(Uwaga pedagogiczna: przykładem kanonicznym modułów w stylu ML nad typeclasses chyba jest utworzenie nowego typu “tree-set”, który akceptuje inne kolejności, a nie ogranicza się do jednej kolejności na typ. Sądzę, że ten przykład się nudzi, bo nie rozwiązuje Prawdziwych Problemów Inżynierii, i bo rozwiązanie typeclasses — utworzenie “typ opakowania” [ang. “wrapper type”] z nową kolejnością — wymaga mniej więcej tyle samo pracy dla programisty, co używanie modułów.)</em></p>

<h2 id="cachowanie-funkcji">Cachowanie funkcji</h2>

<p>Załóżmy, że mamy kosztowne obliczenia, które chcemy cachować (być może wysyłania zapytania do bazy danych lub wykonują dużo pracy związanej z procesorem [ang. “CPU-bound”]). Dla przykładu użyjemy funkcji, która oblicza długość łańcucha:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Called expensive function str_len"</span><span class="p">);</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="cachowanie-indywidualnej-funkcji">Cachowanie indywidualnej funkcji</h3>

<p>Jak napisać funkcję która działa jak <code class="language-plaintext highlighter-rouge">str_len</code>, ale cachuje wyniki w pamięci podręcznej w taki sposób, że nigdy nie obliczy dwukrotnie tej samej pary klucz-wartość? Jednym ze sposobów jest wygenerowanie funkcji opakowania z zmiennym wewnętrznym pamięcią podręczną i wywołanie podstawowe funkcji <code class="language-plaintext highlighter-rouge">str_len</code> kiedy klucza nie ma w pamięci podręcznej:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare that we return an `FnMut` rather than an `Fn`</span>
<span class="c1">// because the returned closure may modify mutable state</span>
<span class="c1">// (and thus isn't safe to call in parallel -- not relevant</span>
<span class="c1">// in this example).</span>
<span class="k">fn</span> <span class="nf">make_cached_str_len</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Use the `move` keyword to move the mutable `cache`</span>
    <span class="c1">// into the returned closure object. Unlike a variable defined</span>
    <span class="c1">// in the closure body itself, this cache will be shared across</span>
    <span class="c1">// *all* invocations of the new function.</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// For simplicity, we clone the `&amp;str` as the cache key</span>
        <span class="c1">// rather than worry about the lifetime annotations here.</span>
        <span class="c1">// If we didn't do this, it's possible that our internal `cache`</span>
        <span class="c1">// would hold a reference to a `str` even after that `str` was freed.</span>
        <span class="k">let</span> <span class="n">key</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="c1">// Look up the entry in our cache,</span>
        <span class="c1">// or create a new one if none exists.</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="o">*</span><span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">make_cached_str_len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Oczywiście, możliwe jest również utworzenie <code class="language-plaintext highlighter-rouge">struct</code>, która cachuje wewnętrzną pamięcię podręczną i po prostu wymaganie wywołującemu wywołania opakowaną funkcję za pomocą metody <code class="language-plaintext highlighter-rouge">.call</code> <em>(uwaga techniczna: Rust obecnie nie obsługuje przeciążania operatora wywołania funkcji)</em>.</p>

<h3 id="cachowanie-funkcji-generyczne">Cachowanie funkcji generyczne</h3>

<p>A teraz abstrahujemy o jeden poziom: a jak chcemy napisać funkcję generyczną do cachowania, która może cachować wyniki <em>dowolnej</em> funkcji, a nie tylko konkretnie <code class="language-plaintext highlighter-rouge">str_len</code>? <em>(Uwaga techniczna: aby uprościć sytuację, ograniczymy się do cachowania wyników tylko tych funkcji, które akceptują dokładnie jeden parametr, ponieważ Rust obecnie nie obsługuje “variadic generics”.)</em> Możemy to osiągnąć za pomocą funkcji generycznej:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a function which is generic over the key and value types,</span>
<span class="c1">// and accepts a "base" function which takes a key and returns a value.</span>
<span class="c1">//</span>
<span class="c1">// In order to store the key in the cache, we had to add the additional</span>
<span class="c1">// bounds `Eq + Hash` to `K`. To simplify the lifetimes, we added</span>
<span class="c1">// the lifetime bound `'static` to `K` and the bound `Clone` to `V`</span>
<span class="c1">// (and cloned the value before returning it).</span>
<span class="k">fn</span> <span class="n">cache_f</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">V</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">f</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A potem nieznacznie dostosowujemy podany parametr, żeby działały typy w tym przykładzie:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// To make some types work, add an additional `&amp;`</span>
    <span class="c1">// to the parameter type.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="uważanie-funkcji-jako-wartość">Uważanie funkcji jako wartość</h3>

<p>Oczywiście z powodu, że zadaliśmy sobie tyle trudu, aby stworzyć tą pamięcię podrzęczną, pewnie chcemy podać ją przekazywać i używać. Idealnie moglibyśmy pisać to tak:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `impl T` does not compile (yet).</span>
<span class="k">type</span> <span class="n">CachedF</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">;</span>
<span class="k">type</span> <span class="n">CachedStrLenF</span> <span class="o">=</span> <span class="n">CachedF</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Niestety, produkuje ten błąd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0658]: `impl Trait` in type aliases is unstable
  --&gt; src/bin/main3-pass-function.rs:24:50
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |                                                  ^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #63063 &lt;https://github.com/rust-lang/rust/issues/63063&gt; for more information

error: non-defining opaque type use in defining scope
  --&gt; src/bin/main3-pass-function.rs:35:5
   |
35 |     accepts_cached_str_len(cached_str_len);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: used non-generic type `&amp;'static str` for generic parameter
  --&gt; src/bin/main3-pass-function.rs:24:14
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |              ^
</code></pre></div></div>

<p>Nie możemy używać <code class="language-plaintext highlighter-rouge">impl Fn</code> w “type alias”, więc musimy to wypisać:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Czyli każde użycie naszej typu funkcji musi zawierać również parametry generycznych typów. To “zaraźliwe” zachowanie szybko staje się nieporęczne w praktyce dla programów nawet o średniej wielkości.</p>

<h2 id="kodowanie-modułów">Kodowanie modułów</h2>

<h3 id="moduły-w-ocaml">Moduły w OCaml</h3>

<p>Moduły w stylu ML mogą ukrywać typy generyczne w sposób, w jaki same funkcje generyczne nie mogą osiągać <em>(uwaga techniczna: używają pewnej formę <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types">typów “existential”</a>)</em>. Aby wyrazić podobny przykład za pomocą modułów w stylu ML, możesz przejrzeć (i chyba nie zrozumieć) następujący kod OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Backend</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span>
    <span class="k">val</span> <span class="n">compute</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">StrLenBackend</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">unit</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="kt">string</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="bp">()</span>
    <span class="k">let</span> <span class="n">compute</span> <span class="bp">()</span> <span class="n">key</span> <span class="o">=</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Computing length of string %s</span><span class="se">\n</span><span class="s2">"</span> <span class="n">key</span><span class="p">;</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">key</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">CachedBackend</span><span class="p">(</span><span class="nc">B</span><span class="o">:</span> <span class="nc">Backend</span><span class="p">)</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compute_cached</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
  <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">backend</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
        <span class="n">cache</span><span class="o">:</span> <span class="p">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="p">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">let</span> <span class="n">make</span> <span class="n">backend</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">;</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="k">let</span> <span class="n">compute_cached</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">compute</span> <span class="n">t</span><span class="o">.</span><span class="n">backend</span> <span class="n">key</span> <span class="k">in</span>
      <span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="n">value</span> <span class="k">in</span>
      <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Ostatecznie chodzi o to, że możesz napisać funkcję taką jak <code class="language-plaintext highlighter-rouge">accepts_cached_str_len</code>, za pomocą typu niegenerycznego, takiego jak <code class="language-plaintext highlighter-rouge">CachedStrLenBackend.t</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">accepts_cached_str_len</span> <span class="p">(</span><span class="n">cached_str_len</span> <span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 1/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 2/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="bp">()</span>
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">StrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cached_str_len</span><span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="n">backend</span> <span class="k">in</span>
  <span class="n">accepts_cached_str_len</span> <span class="n">cached_str_len</span><span class="p">;</span>
 <span class="bp">()</span>
</code></pre></div></div>

<h3 id="associated-typy">“Associated” typy</h3>

<p>Aby osiągnąć coś podobnego do modułów w stylu ML, możemy używać <a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Rust typy “associated”</a> [ang. “associated types”]. Najpierw, zmieniamy nasze typy funkcji w traits <em>(uwaga techniczna: ostatecznie, to jest pewną formą “<a href="https://en.wikipedia.org/wiki/Defunctionalization">defunctionalization</a>”).</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="c1">// We declare "associated types" for this trait. For any type </span>
    <span class="c1">// which implements `Backend`, it must declare corresponding `Key`</span>
    <span class="c1">// and `Value` types, and include an implementation of `compute`</span>
    <span class="c1">// adhering to those types.</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A teraz stworzymy naszą funkcję <code class="language-plaintext highlighter-rouge">str_len</code> jako nowy typ i implementację trait <code class="language-plaintext highlighter-rouge">Backend</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This type doesn't need state, but you could imagine</span>
<span class="c1">// embedding e.g. a database connection in this struct.</span>
<span class="c1">//</span>
<span class="c1">// Normally, types without any data aren't very useful, but</span>
<span class="c1">// this is one of the key ideas of the "encoding of ML-style</span>
<span class="c1">// modules". Instead of state (or in addition to state), the</span>
<span class="c1">// type instead has associated types and functions,</span>
<span class="c1">// declared below.</span>
<span class="c1">//</span>
<span class="c1">// This type corresponds to the "closed-over" variables</span>
<span class="c1">// of a closure object.</span>
<span class="k">struct</span> <span class="n">StrLenBackend</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Jak definiujemy generyczną wersję cachowanego backend, który działa dla dowolnego rodzaju <code class="language-plaintext highlighter-rouge">Backend</code>? Prosta wersja funkcji generycznej tak jak <code class="language-plaintext highlighter-rouge">compute_cached&amp;lt;B: Backend&gt;</code> nie działa, bo chcemy, żeby przechowywał stan. Zamiast tego deklarujemy inny typ, który jest sparametryzowany na typie <code class="language-plaintext highlighter-rouge">Backend</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="c1">// We require that the wrapped backend adheres to these bounds</span>
    <span class="c1">// in order to call any of the functions in this `impl`</span>
    <span class="c1">// (including `new`, which is how you would get a new value</span>
    <span class="c1">// of this type).</span>
    <span class="c1">//</span>
    <span class="c1">// Previously, we had to add the appropriate bounds to </span>
    <span class="c1">// each generic type in each place that it appeared.</span>
    <span class="c1">// Using a `trait`, we can instead declare the bounds</span>
    <span class="c1">// just once on the `impl`.</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="k">self</span><span class="py">.backend</span><span class="nf">.compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Następnie skonstruujemy wartości tych typów i przekazujemy je dalej. Inaczej niż wcześniej, możemy nawet stwarzać “type aliases” dla cachowanego typu funkcji — bez konieczności ponownego określenia parametrów typów generycznych w każdym miejscu.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="n">StrLenBackend</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parametryzowanie-tylko-nad-typami">Parametryzowanie tylko nad typami</h3>

<p>Przekazywanie dalej wartości, które ucieleśniają moduły jest właściwie najpotężniejszą formą tej techniki, odpowiadające “modułom pierwszej-klasy” [ang. “first-class modules”], ale jest to prawdopodobnie  najbardziej naturalna forma wyrażania w Rust, ponieważ większość programistów zajmuje się raczej wartościami niż typami. Idealnie byłoby, gdyby optimizer wyeliminował narzut związany z przekazywaniem wartości, która nie zawiera danych.</p>

<p>Rzadko trzeba to robić, ale można wywoływać tylko na podstawie typu i zakazywać nawet budować wartości. Jest to również interesujące z pedagogicznego punktu widzenia jako przykład “kierowanego-przez-typ” [ang. “type-directed”] generowania kodu w Rust. Aby przepisać powyższy przykład bez tworzenia <code class="language-plaintext highlighter-rouge">Backend</code>, usuniemy wszędzie parametr <code class="language-plaintext highlighter-rouge">&amp;self</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>

    <span class="c1">// We no longer take a value of type `&amp;self`.</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// In Rust, it's not possible to make a value of the type</span>
<span class="c1">// of an empty enum.</span>
<span class="k">enum</span> <span class="n">StrLenBackend</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Następnie dostosujemy  nasz <code class="language-plaintext highlighter-rouge">CachedBackend</code>, żeby bezpośrednio użył <code class="language-plaintext highlighter-rouge">B</code>, zamiast wywołać metody na wartości typu <code class="language-plaintext highlighter-rouge">B</code>, tak jak wywołanie <code class="language-plaintext highlighter-rouge">B::compute</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Note that we no longer have a member of type `B`.</span>
<span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nn">B</span><span class="p">::</span><span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// This weird syntax is equivalent to `CachedBackend&lt;StrLenBackend&gt;::new()`</span>
    <span class="c1">// in some other languages. It's written with an extra `::` due to</span>
    <span class="c1">// technical restrictions on the syntax.</span>
    <span class="c1">//</span>
    <span class="c1">// Note that, unlike before, we never pass a *value* into</span>
    <span class="c1">// the `CachedBackend`, only a type.</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// We could also write the type annotation on the left side and let</span>
    <span class="c1">// type inference figure it out:</span>
    <span class="k">let</span> <span class="n">_also_works</span><span class="p">:</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Or we could use our previously-defined type alias:</span>
    <span class="k">let</span> <span class="n">_also_works</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="inne-kodowania">Inne kodowania</h3>

<p>Moduły w stylu ML obejmują inne funkcje niż powyższe. Oto krótka dyskusja o kodowaniu tamtych funkcji:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">include</code>:
    <ul>
      <li>Można używać poprzednio dyskutowane sposoby, tak jak “extension traits”.</li>
      <li>Albo możesz używać makr — widziałem to w systemach produkcyjnych. (Istnieją dobrze udokumentowane problemy z makrami, których tutaj nie omówię.)</li>
    </ul>
  </li>
  <li>Aktualizowanie modułów, czyli tworzenie nowej definicji istniejącego modułu z przedefiniowanym jednym z typów “associated”.
    <ul>
      <li>Poza makrami, nie widziałem kodowania na to.</li>
    </ul>
  </li>
  <li>Typowanie strukturalne [ang. “<a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a>”]
    <ul>
      <li>Rust po prostu nie pozwala strukturalnego typowania obiektów podobnych do modułów. Możesz spróbować zmienić swoje implicytne strukturalne typy na eksplicytne hierarchię traits.</li>
      <li>Albo możesz używać makr.</li>
    </ul>
  </li>
  <li>“Applicative” vs “generative” funktory
    <ul>
      <li>Zobacz <a href="https://stackoverflow.com/q/52161048/344643">https://stackoverflow.com/questions/52161048/applicative-vs-generative-functors</a></li>
      <li>Zależy od konkretnego kodowania modułu. Abstrakcje typów są wprowadzone ręcznie typami “associated” i zawsze są nierówne, podczas gdy typy przekazywane przez parametr typu generycznego mogą być uważane równe. Więc jeśli chcesz funktor generatywnego, możesz bezpośrednio wprowadzić nowy typ abstrakcyjny poprzez kolejną warstwę <code class="language-plaintext highlighter-rouge">trait</code> z typem “associated”.</li>
    </ul>
  </li>
</ul>

<p>Zobacz też <a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/">The AST typing problem</a>, abe znaleźć powiązane pytania dotyczące praktycznego kodowania modułów.</p>

<h2 id="powiązane-posty">Powiązane posty</h2>

<p>Poniżej znajduje się kilka ręcznie wybranych postów, które mogą Cię zainteresować.</p>

<table class="related-posts">
<thead>
  <tr>
    <th>Date</th>
    <th></th>
    <th>Title</th>
  </tr>
</thead>

<tbody>


  <tr>
    <td>17&nbsp;Jun&nbsp;2023</td>
    <td class="this-post">
      
      (this&nbsp;post)
      
      </td>
    <td><a href="/kodowanie-w-rust-modułów-w-stylu-ml/">Kodowanie w Rust modułów w stylu ML</a>
    </td>
  </tr>

</tbody>
</table>

<p>Chcesz zobaczyć więcej moich postów? Obserwuj mnie <a href="https://twitter.com/arxanas">na Twitterze</a> albo subskrybuj <a href="/pl/feed.xml">za pomocą RSS</a>.</p>

<h2 id="komentarze">Komentarze</h2>

<ul>



</ul>

<script type="text/javascript" src="/scripts/github-comment-links.js"></script>

<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://blog.waleedkhan.name/pl/kodowanie-w-rust-modułów-w-stylu-ml/";
    this.page.identifier = "kodowanie-w-rust-modułów-w-stylu-ml/";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//waleedkhan-name.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Steno & PL</h2>
    
    <p class="rss-subscribe">subskrybuj <a href="/pl/feed.xml">za pomocą RSS</a></p>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Waleed Khan</li>
          <li><a href="mailto:me@waleedkhan.name">me@waleedkhan.name</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/arxanas"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/arxanas"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>To jest blog osobisty. Jeśli nie wykazano inaczej, wyrażone tutaj opinie są moimi własnymi, a nie opiniami moich byłych lub obecnych pracodawców.</p>
      </div>
    </div>

  </div>

  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53066274-1', 'auto');
ga('send', 'pageview');
</script>



</footer>


  </body>

</html>
