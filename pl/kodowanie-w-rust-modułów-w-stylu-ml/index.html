<!DOCTYPE html>
<html lang="pl">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
    <title>Kodowanie w Rust moduÅ‚Ã³w w stylu ML</title>
  
  <meta name="author" content="Waleed Khan">
  <meta name="description" content="            Docelowi odbiorcy              ProgramiÅ›ci OCaml/SML uczÄ…cy siÄ™ jÄ™zyka Rust.        ProgramiÅ›ci funkcjonalni, ktÃ³rzy wczeÅ›niej nie mieli stycznoÅ›...">

  <link rel="stylesheet" href="/pl/css/main.css">
  <link rel="canonical" href="https://blog.waleedkhan.name/pl/kodowanie-w-rust-moduÅ‚Ã³w-w-stylu-ml/">
  <link rel="alternate" type="application/rss+xml" title="Steno & PL" href="https://blog.waleedkhan.name/pl/feed.xml">
  <script src="//instant.page/5.1.0" type="module" integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
  

  <link rel="me" href="https://github.com/arxanas">
  <link rel="me" href="https://twitter.com/arxanas">
  <link rel="me" href="mailto:me@waleedkhan.name">

  
  

  <!-- See https://indieweb.org/webmention.io -->
  <link rel="webmention" href="https://webmention.io/blog.waleedkhan.name/webmention" />
  <link rel="pingback" href="https://webmention.io/webmention?forward=https://blog.waleedkhan.name/webmention" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/pl/">Steno & PL</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          <a class="page-link" href="/pl/o-mnie/">O mnie</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Kodowanie w Rust moduÅ‚Ã³w w stylu ML</h1>
    <p class="post-meta"><time datetime="2023-06-17T00:00:00+00:00" itemprop="datePublished">Jun 17, 2023</time>
    
      <span class="post-meta">
        <br />
        
        <a href="/encoding-ml-style-modules-in-rust/">Read in English ğŸ‡ºğŸ‡¸</a>
        
      </span>
    
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
    <div class="publication-notes">
  <table>
    <tr>
      <td>Docelowi odbiorcy</td>
      <td><ul>
        <li>ProgramiÅ›ci OCaml/SML uczÄ…cy siÄ™ jÄ™zyka Rust.</li>
        <li>ProgramiÅ›ci funkcjonalni, ktÃ³rzy wczeÅ›niej nie mieli stycznoÅ›ci z jÄ™zykÃ³w takimi jak OCaml czy Haskell, ale mogÄ… byÄ‡ zainteresowani pewnÄ… technikÄ… abstrakcji.</li>
        <ul><li>
        NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e termin â€œmoduÅ‚ w stylu MLâ€ odnosi siÄ™ do <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">rodziny jÄ™zykÃ³w programowania ML</a>, a nie do <a href="https://pl.wikipedia.org/wiki/Uczenie_maszynowe">uczenia maszynowego</a>.
        </li></ul>
      </ul>
      </td>
    </tr>
    <tr>
      <td>Pochodzenie</td>
      <td><ul>
        <li>DoÅ›wiadczenie w OCaml i Rust.</li>
        <li>DoÅ›wiadczenie w teorii typÃ³w.</li>
      </ul></td>
    </tr>
    <tr>
      <td>NastrÃ³j</td>
      <td>Pomocny</td>
    </tr>
    
<tr>
  <td>JÄ™zyk</td>
  <td>Obcy. Moim pierwszym jÄ™zyk jest angielki. JeÅ›li zobaczysz bÅ‚Ä…d, niezaleÅ¼nie od tego, czy chodzi o pisowniÄ™, gramatykÄ™ czy dobÃ³r sÅ‚ow, skomentuj to!</td>
</tr>


  </table>
</div>

<div class="series-and-toc">

  <p class="toc-header">Spis treÅ›ci:</p>

<ul id="markdown-toc">
  <li><a href="#stwierdzenie-problemu" id="markdown-toc-stwierdzenie-problemu">Stwierdzenie problemu</a></li>
  <li><a href="#cachowanie-funkcji" id="markdown-toc-cachowanie-funkcji">Cachowanie funkcji</a>    <ul>
      <li><a href="#cachowanie-indywidualnej-funkcji" id="markdown-toc-cachowanie-indywidualnej-funkcji">Cachowanie indywidualnej funkcji</a></li>
      <li><a href="#cachowanie-funkcji-generyczne" id="markdown-toc-cachowanie-funkcji-generyczne">Cachowanie funkcji generyczne</a></li>
      <li><a href="#uwaÅ¼anie-funkcji-jako-wartoÅ›Ä‡" id="markdown-toc-uwaÅ¼anie-funkcji-jako-wartoÅ›Ä‡">UwaÅ¼anie funkcji jako wartoÅ›Ä‡</a></li>
    </ul>
  </li>
  <li><a href="#kodowanie-moduÅ‚Ã³w" id="markdown-toc-kodowanie-moduÅ‚Ã³w">Kodowanie moduÅ‚Ã³w</a>    <ul>
      <li><a href="#moduÅ‚y-w-ocaml" id="markdown-toc-moduÅ‚y-w-ocaml">ModuÅ‚y w OCaml</a></li>
      <li><a href="#associated-typy" id="markdown-toc-associated-typy">â€œAssociatedâ€ typy</a></li>
      <li><a href="#parametryzowanie-tylko-nad-typami" id="markdown-toc-parametryzowanie-tylko-nad-typami">Parametryzowanie tylko nad typami</a></li>
      <li><a href="#inne-kodowania" id="markdown-toc-inne-kodowania">Inne kodowania</a></li>
    </ul>
  </li>
  <li><a href="#powiÄ…zane-posty" id="markdown-toc-powiÄ…zane-posty">PowiÄ…zane posty</a></li>
  <li><a href="#komentarze" id="markdown-toc-komentarze">Komentarze</a></li>
</ul>

</div>

<h2 id="stwierdzenie-problemu">Stwierdzenie problemu</h2>

<p>Problem: chcesz dodaÄ‡ do istniejÄ…cego typu implementujÄ…cego pewnego trait nowÄ… dziaÅ‚alnoÅ›Ä‡, ktÃ³ra bÄ™dzie wymagaÅ‚a uÅ¼ywania wewnÄ™trznego stanu.</p>

<p>Problem: chcesz wziÄ…Ä‡ istniejÄ…cy typ speÅ‚niajÄ…cy jakÄ…Å› cechÄ™ i rozszerzyÄ‡ go o nowÄ… funkcjonalnoÅ›Ä‡ â€” w tym nowy stan wewnÄ™trzny.</p>

<p>JeÅ›li nie chcesz dodaÄ‡ wewnÄ™trznego stanu, istnieje kilka moÅ¼liwych rozwiÄ…zaÅ„:</p>

<ul>
  <li>UÅ¼ywaÄ‡ domyÅ›lnych implementacji metod trait.</li>
  <li>UÅ¼ywaÄ‡ â€œextension traitsâ€.</li>
  <li>UÅ¼ywaÄ‡ <code class="language-plaintext highlighter-rouge">impl dyn</code> <em>(uwaga techniczna: bÄ™dzie to wymagaÄ‡ dynamicznego wywoÅ‚ywania na czasie wykonywania)</em>.</li>
  <li>UÅ¼ywaÄ‡ wolnych (globalnych) funkcji, ktÃ³re sÄ… generyczne i akceptujÄ… dowolny typ implementujÄ…cy trait.</li>
</ul>

<p>Na przykÅ‚ad: implementowanie warstwa cachowania [ang. â€œcachingâ€] tylko <em>raz</em>, ktÃ³re mogÅ‚o wtedy zastosowaÄ‡ siÄ™ do <em>dowolnej</em> implementacji jakiegoÅ› trait <code class="language-plaintext highlighter-rouge">Backend</code>.</p>

<p>ModuÅ‚y w stylu ML sÄ… naturalnym rozwiÄ…zaniem dla tego rodzaju problemÃ³w. Bardziej wydajne sÄ… one niÅ¼ tradycyjne â€œmoduÅ‚yâ€, jak uwaÅ¼a siÄ™ w popularnych jÄ™zykach programowania. ZarÃ³wno moduÅ‚y w stylu ML, jak i tradycyjne moduÅ‚y obsÅ‚ugujÄ…:</p>

<ul>
  <li>Rozdzielanie kodu na logiczne przestrzenie nazw [ang. â€œnamespacesâ€].</li>
  <li>Definiowanie interfejsÃ³w.</li>
  <li>Abstrahowanie typÃ³w danych i ukrywanie szczegÃ³Å‚Ã³w implementacji.</li>
</ul>

<p>Ponadto moduÅ‚y w stylu ML mogÄ… byÄ‡ parametryzowane na <em>typach</em> (podobnie szablonom [ang. â€œtemplatesâ€] lub typom generycznym w innych jÄ™zykach programowania), a takÅ¼e _innych moduÅ‚ach _(omÃ³wione w tym artykule).</p>

<p>Pomimo, Å¼e Rust pochodzi z OCaml, nie dziedziczy systemu moduÅ‚Ã³w w stylu ML. Zamiast, system â€œtraitâ€ w Rust przypomina <a href="https://en.wikipedia.org/wiki/Type_class">typeclasses z Haskell</a>. Jednak, korzystajÄ…cy dodatkowych funkcji, moÅ¼emy symulowaÄ‡ w Rust moduÅ‚y w stylu ML.</p>

<p><em>(Uwaga pedagogiczna: przykÅ‚adem kanonicznym moduÅ‚Ã³w w stylu ML nad typeclasses chyba jest utworzenie nowego typu â€œtree-setâ€, ktÃ³ry akceptuje inne kolejnoÅ›ci, a nie ogranicza siÄ™ do jednej kolejnoÅ›ci na typ. SÄ…dzÄ™, Å¼e ten przykÅ‚ad siÄ™Â nudzi, bo nie rozwiÄ…zuje Prawdziwych ProblemÃ³w InÅ¼ynierii, i bo rozwiÄ…zanie typeclasses â€” utworzenie â€œtyp opakowaniaâ€ [ang. â€œwrapper typeâ€] z nowÄ… kolejnoÅ›ciÄ… â€”Â wymaga mniej wiÄ™cej tyle samo pracy dla programisty, co uÅ¼ywanie moduÅ‚Ã³w.)</em></p>

<h2 id="cachowanie-funkcji">Cachowanie funkcji</h2>

<p>ZaÅ‚Ã³Å¼my, Å¼e mamy kosztowne obliczenia, ktÃ³re chcemy cachowaÄ‡ (byÄ‡ moÅ¼e wysyÅ‚ania zapytania do bazy danych lub wykonujÄ… duÅ¼o pracy zwiÄ…zanej z procesorem [ang. â€œCPU-boundâ€]). Dla przykÅ‚adu uÅ¼yjemy funkcji, ktÃ³ra oblicza dÅ‚ugoÅ›Ä‡ Å‚aÅ„cucha:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Called expensive function str_len"</span><span class="p">);</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="cachowanie-indywidualnej-funkcji">Cachowanie indywidualnej funkcji</h3>

<p>Jak napisaÄ‡ funkcjÄ™ ktÃ³ra dziaÅ‚a jak <code class="language-plaintext highlighter-rouge">str_len</code>, ale cachuje wyniki w pamiÄ™ci podrÄ™cznej w taki sposÃ³b, Å¼e nigdy nie obliczy dwukrotnie tej samej pary klucz-wartoÅ›Ä‡? Jednym ze sposobÃ³w jest wygenerowanie funkcji opakowania z zmiennym wewnÄ™trznym pamiÄ™ciÄ… podrÄ™cznÄ… i wywoÅ‚anie podstawowe funkcji <code class="language-plaintext highlighter-rouge">str_len</code> kiedy klucza nie ma w pamiÄ™ci podrÄ™cznej:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare that we return an `FnMut` rather than an `Fn`</span>
<span class="c1">// because the returned closure may modify mutable state</span>
<span class="c1">// (and thus isn't safe to call in parallel -- not relevant</span>
<span class="c1">// in this example).</span>
<span class="k">fn</span> <span class="nf">make_cached_str_len</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Use the `move` keyword to move the mutable `cache`</span>
    <span class="c1">// into the returned closure object. Unlike a variable defined</span>
    <span class="c1">// in the closure body itself, this cache will be shared across</span>
    <span class="c1">// *all* invocations of the new function.</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// For simplicity, we clone the `&amp;str` as the cache key</span>
        <span class="c1">// rather than worry about the lifetime annotations here.</span>
        <span class="c1">// If we didn't do this, it's possible that our internal `cache`</span>
        <span class="c1">// would hold a reference to a `str` even after that `str` was freed.</span>
        <span class="k">let</span> <span class="n">key</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="c1">// Look up the entry in our cache,</span>
        <span class="c1">// or create a new one if none exists.</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="o">*</span><span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">make_cached_str_len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>OczywiÅ›cie, moÅ¼liwe jest rÃ³wnieÅ¼ utworzenie <code class="language-plaintext highlighter-rouge">struct</code>, ktÃ³ra cachuje wewnÄ™trznÄ… pamiÄ™ciÄ™ podrÄ™cznÄ… i po prostu wymaganie wywoÅ‚ujÄ…cemu wywoÅ‚ania opakowanÄ… funkcjÄ™ za pomocÄ… metody <code class="language-plaintext highlighter-rouge">.call</code> <em>(uwaga techniczna: Rust obecnie nie obsÅ‚uguje przeciÄ…Å¼ania operatora wywoÅ‚ania funkcji)</em>.</p>

<h3 id="cachowanie-funkcji-generyczne">Cachowanie funkcji generyczne</h3>

<p>A teraz abstrahujemyÂ o jeden poziom: a jak chcemy napisaÄ‡ funkcjÄ™ generycznÄ… do cachowania, ktÃ³ra moÅ¼e cachowaÄ‡ wyniki <em>dowolnej</em> funkcji, a nie tylko konkretnie <code class="language-plaintext highlighter-rouge">str_len</code>? <em>(Uwaga techniczna: aby uproÅ›ciÄ‡ sytuacjÄ™, ograniczymy siÄ™ do cachowania wynikÃ³w tylko tych funkcji, ktÃ³re akceptujÄ… dokÅ‚adnie jeden parametr, poniewaÅ¼Â Rust obecnie nie obsÅ‚uguje â€œvariadic genericsâ€.)</em> MoÅ¼emy to osiÄ…gnÄ…Ä‡ za pomocÄ… funkcji generycznej:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a function which is generic over the key and value types,</span>
<span class="c1">// and accepts a "base" function which takes a key and returns a value.</span>
<span class="c1">//</span>
<span class="c1">// In order to store the key in the cache, we had to add the additional</span>
<span class="c1">// bounds `Eq + Hash` to `K`. To simplify the lifetimes, we added</span>
<span class="c1">// the lifetime bound `'static` to `K` and the bound `Clone` to `V`</span>
<span class="c1">// (and cloned the value before returning it).</span>
<span class="k">fn</span> <span class="n">cache_f</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">V</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">f</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A potem nieznacznie dostosowujemy podany parametr, Å¼eby dziaÅ‚aÅ‚y typy w tym przykÅ‚adzie:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// To make some types work, add an additional `&amp;`</span>
    <span class="c1">// to the parameter type.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="uwaÅ¼anie-funkcji-jako-wartoÅ›Ä‡">UwaÅ¼anie funkcji jako wartoÅ›Ä‡</h3>

<p>OczywiÅ›cie z powodu, Å¼e zadaliÅ›my sobie tyle trudu, aby stworzyÄ‡ tÄ… pamiÄ™ciÄ™ podrzÄ™cznÄ…, pewnie chcemy podaÄ‡ jÄ… przekazywaÄ‡ i uÅ¼ywaÄ‡. Idealnie moglibyÅ›my pisaÄ‡ to tak:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `impl T` does not compile (yet).</span>
<span class="k">type</span> <span class="n">CachedF</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">;</span>
<span class="k">type</span> <span class="n">CachedStrLenF</span> <span class="o">=</span> <span class="n">CachedF</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Niestety, produkuje ten bÅ‚Ä…d:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0658]: `impl Trait` in type aliases is unstable
  --&gt; src/bin/main3-pass-function.rs:24:50
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |                                                  ^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #63063 &lt;https://github.com/rust-lang/rust/issues/63063&gt; for more information

error: non-defining opaque type use in defining scope
  --&gt; src/bin/main3-pass-function.rs:35:5
   |
35 |     accepts_cached_str_len(cached_str_len);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: used non-generic type `&amp;'static str` for generic parameter
  --&gt; src/bin/main3-pass-function.rs:24:14
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |              ^
</code></pre></div></div>

<p>Nie moÅ¼emy uÅ¼ywaÄ‡ <code class="language-plaintext highlighter-rouge">impl Fn</code> w â€œtype aliasâ€, wiÄ™c musimy to wypisaÄ‡:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Czyli kaÅ¼de uÅ¼ycie naszej typu funkcji musi zawieraÄ‡ rÃ³wnieÅ¼ parametry generycznych typÃ³w. To â€œzaraÅºliweâ€ zachowanie szybko staje siÄ™Â nieporÄ™czne w praktyce dla programÃ³w nawet o Å›redniej wielkoÅ›ci.</p>

<h2 id="kodowanie-moduÅ‚Ã³w">Kodowanie moduÅ‚Ã³w</h2>

<h3 id="moduÅ‚y-w-ocaml">ModuÅ‚y w OCaml</h3>

<p>ModuÅ‚y w stylu ML mogÄ… ukrywaÄ‡ typy generyczne w sposÃ³b, w jaki same funkcje generyczne nie mogÄ… osiÄ…gaÄ‡ <em>(uwaga techniczna: uÅ¼ywajÄ… pewnej formÄ™ <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types">typÃ³w â€œexistentialâ€</a>)</em>. Aby wyraziÄ‡ podobny przykÅ‚ad za pomocÄ… moduÅ‚Ã³w w stylu ML, moÅ¼esz przejrzeÄ‡ (i chyba nie zrozumieÄ‡) nastÄ™pujÄ…cy kod OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Backend</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span>
    <span class="k">val</span> <span class="n">compute</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">StrLenBackend</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">unit</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="kt">string</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="bp">()</span>
    <span class="k">let</span> <span class="n">compute</span> <span class="bp">()</span> <span class="n">key</span> <span class="o">=</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Computing length of string %s</span><span class="se">\n</span><span class="s2">"</span> <span class="n">key</span><span class="p">;</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">key</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">CachedBackend</span><span class="p">(</span><span class="nc">B</span><span class="o">:</span> <span class="nc">Backend</span><span class="p">)</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compute_cached</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
  <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">backend</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
        <span class="n">cache</span><span class="o">:</span> <span class="p">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="p">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">let</span> <span class="n">make</span> <span class="n">backend</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">;</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="k">let</span> <span class="n">compute_cached</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">compute</span> <span class="n">t</span><span class="o">.</span><span class="n">backend</span> <span class="n">key</span> <span class="k">in</span>
      <span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="n">value</span> <span class="k">in</span>
      <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Ostatecznie chodzi o to, Å¼e moÅ¼esz napisaÄ‡ funkcjÄ™ takÄ… jak <code class="language-plaintext highlighter-rouge">accepts_cached_str_len</code>, za pomocÄ… typu niegenerycznego, takiego jak <code class="language-plaintext highlighter-rouge">CachedStrLenBackend.t</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">accepts_cached_str_len</span> <span class="p">(</span><span class="n">cached_str_len</span> <span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 1/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 2/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="bp">()</span>
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">StrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cached_str_len</span><span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="n">backend</span> <span class="k">in</span>
  <span class="n">accepts_cached_str_len</span> <span class="n">cached_str_len</span><span class="p">;</span>
 <span class="bp">()</span>
</code></pre></div></div>

<h3 id="associated-typy">â€œAssociatedâ€ typy</h3>

<p>Aby osiÄ…gnÄ…Ä‡ coÅ› podobnego do moduÅ‚Ã³w w stylu ML, moÅ¼emy uÅ¼ywaÄ‡ <a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Rust typy â€œassociatedâ€</a> [ang. â€œassociated typesâ€]. Najpierw, zmieniamy nasze typy funkcji w traits <em>(uwaga techniczna: ostatecznie, to jest pewnÄ… formÄ… â€œ<a href="https://en.wikipedia.org/wiki/Defunctionalization">defunctionalization</a>â€).</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="c1">// We declare "associated types" for this trait. For any type </span>
    <span class="c1">// which implements `Backend`, it must declare corresponding `Key`</span>
    <span class="c1">// and `Value` types, and include an implementation of `compute`</span>
    <span class="c1">// adhering to those types.</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A teraz stworzymy naszÄ…Â funkcjÄ™ <code class="language-plaintext highlighter-rouge">str_len</code> jako nowy typ i implementacjÄ™ trait <code class="language-plaintext highlighter-rouge">Backend</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This type doesn't need state, but you could imagine</span>
<span class="c1">// embedding e.g. a database connection in this struct.</span>
<span class="c1">//</span>
<span class="c1">// Normally, types without any data aren't very useful, but</span>
<span class="c1">// this is one of the key ideas of the "encoding of ML-style</span>
<span class="c1">// modules". Instead of state (or in addition to state), the</span>
<span class="c1">// type instead has associated types and functions,</span>
<span class="c1">// declared below.</span>
<span class="c1">//</span>
<span class="c1">// This type corresponds to the "closed-over" variables</span>
<span class="c1">// of a closure object.</span>
<span class="k">struct</span> <span class="n">StrLenBackend</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Jak definiujemy generycznÄ… wersjÄ™ cachowanego backend, ktÃ³ry dziaÅ‚a dla dowolnego rodzaju <code class="language-plaintext highlighter-rouge">Backend</code>? Prosta wersja funkcji generycznej tak jak <code class="language-plaintext highlighter-rouge">compute_cached&amp;lt;B: Backend&gt;</code> nie dziaÅ‚a, bo chcemy, Å¼eby przechowywaÅ‚ stan. Zamiast tego deklarujemy inny typ, ktÃ³ry jest sparametryzowany na typie <code class="language-plaintext highlighter-rouge">Backend</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="c1">// We require that the wrapped backend adheres to these bounds</span>
    <span class="c1">// in order to call any of the functions in this `impl`</span>
    <span class="c1">// (including `new`, which is how you would get a new value</span>
    <span class="c1">// of this type).</span>
    <span class="c1">//</span>
    <span class="c1">// Previously, we had to add the appropriate bounds to </span>
    <span class="c1">// each generic type in each place that it appeared.</span>
    <span class="c1">// Using a `trait`, we can instead declare the bounds</span>
    <span class="c1">// just once on the `impl`.</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="k">self</span><span class="py">.backend</span><span class="nf">.compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>NastÄ™pnie skonstruujemy wartoÅ›ci tych typÃ³w i przekazujemy je dalej. Inaczej niÅ¼ wczeÅ›niej, moÅ¼emy nawet stwarzaÄ‡ â€œtype aliasesâ€ dla cachowanego typu funkcji â€”Â bez koniecznoÅ›ci ponownego okreÅ›lenia parametrÃ³w typÃ³w generycznych w kaÅ¼dym miejscu.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="n">StrLenBackend</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parametryzowanie-tylko-nad-typami">Parametryzowanie tylko nad typami</h3>

<p>Przekazywanie dalej wartoÅ›ci, ktÃ³re ucieleÅ›niajÄ… moduÅ‚y jest wÅ‚aÅ›ciwie najpotÄ™Å¼niejszÄ… formÄ… tej techniki, odpowiadajÄ…ce â€œmoduÅ‚om pierwszej-klasyâ€ [ang. â€œfirst-class modulesâ€], ale jest to prawdopodobnie  najbardziej naturalna forma wyraÅ¼ania w Rust, poniewaÅ¼Â wiÄ™kszoÅ›Ä‡ programistÃ³w zajmujeÂ siÄ™ raczej wartoÅ›ciami niÅ¼Â typami. Idealnie byÅ‚oby, gdyby optimizer wyeliminowaÅ‚Â narzut zwiÄ…zany z przekazywaniem wartoÅ›ci, ktÃ³ra nie zawiera danych.</p>

<p>Rzadko trzeba to robiÄ‡, ale moÅ¼na wywoÅ‚ywaÄ‡ tylko na podstawie typu i zakazywaÄ‡ nawet budowaÄ‡ wartoÅ›ci. Jest to rÃ³wnieÅ¼ interesujÄ…ce z pedagogicznego punktu widzenia jako przykÅ‚ad â€œkierowanego-przez-typâ€ [ang. â€œtype-directedâ€] generowania kodu w Rust. Aby przepisaÄ‡ powyÅ¼szy przykÅ‚ad bez tworzenia <code class="language-plaintext highlighter-rouge">Backend</code>, usuniemy wszÄ™dzie parametr <code class="language-plaintext highlighter-rouge">&amp;self</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>

    <span class="c1">// We no longer take a value of type `&amp;self`.</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// In Rust, it's not possible to make a value of the type</span>
<span class="c1">// of an empty enum.</span>
<span class="k">enum</span> <span class="n">StrLenBackend</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>NastÄ™pnie dostosujemy  nasz <code class="language-plaintext highlighter-rouge">CachedBackend</code>, Å¼eby bezpoÅ›rednio uÅ¼yÅ‚ <code class="language-plaintext highlighter-rouge">B</code>, zamiast wywoÅ‚aÄ‡ metody na wartoÅ›ci typu <code class="language-plaintext highlighter-rouge">B</code>, tak jak wywoÅ‚anie <code class="language-plaintext highlighter-rouge">B::compute</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Note that we no longer have a member of type `B`.</span>
<span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nn">B</span><span class="p">::</span><span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// This weird syntax is equivalent to `CachedBackend&lt;StrLenBackend&gt;::new()`</span>
    <span class="c1">// in some other languages. It's written with an extra `::` due to</span>
    <span class="c1">// technical restrictions on the syntax.</span>
    <span class="c1">//</span>
    <span class="c1">// Note that, unlike before, we never pass a *value* into</span>
    <span class="c1">// the `CachedBackend`, only a type.</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// We could also write the type annotation on the left side and let</span>
    <span class="c1">// type inference figure it out:</span>
    <span class="k">let</span> <span class="n">_also_works</span><span class="p">:</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Or we could use our previously-defined type alias:</span>
    <span class="k">let</span> <span class="n">_also_works</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="inne-kodowania">Inne kodowania</h3>

<p>ModuÅ‚y w stylu ML obejmujÄ… inne funkcje niÅ¼ powyÅ¼sze. Oto krÃ³tka dyskusja o kodowaniu tamtych funkcji:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">include</code>:
    <ul>
      <li>MoÅ¼na uÅ¼ywaÄ‡ poprzednio dyskutowane sposoby, tak jak â€œextension traitsâ€.</li>
      <li>Albo moÅ¼esz uÅ¼ywaÄ‡ makr â€”Â widziaÅ‚em to w systemach produkcyjnych. (IstniejÄ… dobrze udokumentowane problemy z makrami, ktÃ³rych tutaj nie omÃ³wiÄ™.)</li>
    </ul>
  </li>
  <li>Aktualizowanie moduÅ‚Ã³w, czyli tworzenie nowej definicji istniejÄ…cego moduÅ‚u z przedefiniowanym jednym z typÃ³w â€œassociatedâ€.
    <ul>
      <li>Poza makrami, nie widziaÅ‚em kodowania na to.</li>
    </ul>
  </li>
  <li>Typowanie strukturalne [ang. â€œ<a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a>â€]
    <ul>
      <li>Rust po prostu nie pozwala strukturalnego typowania obiektÃ³w podobnych do moduÅ‚Ã³w. MoÅ¼esz sprÃ³bowaÄ‡ zmieniÄ‡ swoje implicytne strukturalne typy na eksplicytne hierarchiÄ™ traits.</li>
      <li>Albo moÅ¼esz uÅ¼ywaÄ‡ makr.</li>
    </ul>
  </li>
  <li>â€œApplicativeâ€ vs â€œgenerativeâ€ funktory
    <ul>
      <li>Zobacz <a href="https://stackoverflow.com/q/52161048/344643">https://stackoverflow.com/questions/52161048/applicative-vs-generative-functors</a></li>
      <li>ZaleÅ¼y od konkretnego kodowania moduÅ‚u. Abstrakcje typÃ³w sÄ… wprowadzone rÄ™cznie typami â€œassociatedâ€ i zawsze sÄ…Â nierÃ³wne, podczas gdy typy przekazywane przez parametr typu generycznego mogÄ… byÄ‡ uwaÅ¼ane rÃ³wne. WiÄ™c jeÅ›li chcesz funktor generatywnego, moÅ¼esz bezpoÅ›rednio wprowadziÄ‡ nowy typ abstrakcyjny poprzez kolejnÄ… warstwÄ™ <code class="language-plaintext highlighter-rouge">trait</code> z typem â€œassociatedâ€.</li>
    </ul>
  </li>
</ul>

<p>Zobacz teÅ¼ <a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/">The AST typing problem</a>, abe znaleÅºÄ‡ powiÄ…zane pytania dotyczÄ…ce praktycznego kodowania moduÅ‚Ã³w.</p>

<h2 id="powiÄ…zane-posty">PowiÄ…zane posty</h2>

<p>PoniÅ¼ej znajduje siÄ™ kilka rÄ™cznie wybranych postÃ³w, ktÃ³re mogÄ… CiÄ™ zainteresowaÄ‡.</p>

<table class="related-posts">
<thead>
  <tr>
    <th>Date</th>
    <th></th>
    <th>Title</th>
  </tr>
</thead>

<tbody>


  <tr>
    <td>17&nbsp;Jun&nbsp;2023</td>
    <td class="this-post">
      
      (this&nbsp;post)
      
      </td>
    <td><a href="/kodowanie-w-rust-moduÅ‚Ã³w-w-stylu-ml/">Kodowanie w Rust moduÅ‚Ã³w w stylu ML</a>
    </td>
  </tr>

</tbody>
</table>

<p>Chcesz zobaczyÄ‡ wiÄ™cej moich postÃ³w? Obserwuj mnie <a href="https://twitter.com/arxanas">na Twitterze</a> albo subskrybuj <a href="/pl/feed.xml">za pomocÄ… RSS</a>.</p>

<h2 id="komentarze">Komentarze</h2>

<ul>



</ul>

<script type="text/javascript" src="/scripts/github-comment-links.js"></script>

<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://blog.waleedkhan.name/pl/kodowanie-w-rust-moduÅ‚Ã³w-w-stylu-ml/";
    this.page.identifier = "kodowanie-w-rust-moduÅ‚Ã³w-w-stylu-ml/";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//waleedkhan-name.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Steno & PL</h2>
    
    <p class="rss-subscribe">subskrybuj <a href="/pl/feed.xml">za pomocÄ… RSS</a></p>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Waleed Khan</li>
          <li><a href="mailto:me@waleedkhan.name">me@waleedkhan.name</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/arxanas"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/arxanas"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>To jest blog osobisty. JeÅ›li nie wykazano inaczej, wyraÅ¼one tutaj opinie sÄ… moimi wÅ‚asnymi, a nie opiniami moich byÅ‚ych lub obecnych pracodawcÃ³w.</p>
      </div>
    </div>

  </div>

  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53066274-1', 'auto');
ga('send', 'pageview');
</script>



</footer>


  </body>

</html>
