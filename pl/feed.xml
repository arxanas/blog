<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Steno &amp; PL</title>
    <description>This is a personal blog. Unless otherwise stated, the opinions
expressed here are my own, and not those of my past or present
employers.</description>
    <link>https://blog.waleedkhan.name/pl/</link>
    <atom:link href="https://blog.waleedkhan.name/pl/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 07 Feb 2023 18:29:03 -0600</pubDate>
    <lastBuildDate>Tue, 07 Feb 2023 18:29:03 -0600</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Ulepszenie czasów in Rust</title>
        <description>&lt;p&gt;&lt;em&gt;Docelowi odbiorcy: potencjalni i średnio-zaawansowani deweloperzy Rust, którzy martwią się wolnymi czasami kompilacji, ich skalą i praktykami zapobiegawczymi; zaawansowani deweloperzy Rust, którzy pomogą mi poprawić czas kompilacji.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Rust jest znany z wolnego czasu kompilacji. Spędziłem dużo czasu próbując poprawić przyrostowe czasy kompilacji testowania dla mojego projektu &lt;a href=&quot;https://github.com/arxanas/git-branchless&quot;&gt;git-branchless&lt;/a&gt; w &lt;a href=&quot;https://github.com/arxanas/git-branchless/pull/650&quot;&gt;https://github.com/arxanas/git-branchless/pull/650&lt;/a&gt;. Oto dyskusja wyników.&lt;/p&gt;

&lt;h1 id=&quot;streszczenie-wykonawcze&quot;&gt;Streszczenie wykonawcze&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;“Przyrostowe testowania” odnosi się tylko do zmiany kodu testu integracyjnego i przebudowanie. Kod źródłowy pozostaje niezmienony.&lt;/li&gt;
  &lt;li&gt;Ostatecznie udało mi się skrócić przyrostowy czas testowania z ~6.9sek do ~1.7sek (~4x). Inne sposoby na skrócenie czasu kompilacji przyniosły niewielką lub żadną poprawę.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;W celach informacyjnych, oto najlepsze artykuły dotyczące konceptualnego zrozumienia modelu kompilacji Rust i poprawy czasu kompilacji:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://matklad.github.io/2021/09/04/fast-rust-builds.html&quot;&gt;Fast Rust Builds&lt;/a&gt; (&lt;a href=&quot;https://matklad.github.io&quot;&gt;matklad.github.io&lt;/a&gt;, 2021)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://matklad.github.io/2021/05/31/how-to-test.html&quot;&gt;How to Test&lt;/a&gt; (&lt;a href=&quot;https://matklad.github.io&quot;&gt;matklad.github.io&lt;/a&gt;, 2021)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://fasterthanli.me/articles/why-is-my-rust-build-so-slow&quot;&gt;Why is my Rust build so slow?&lt;/a&gt; (&lt;a href=&quot;https://fasterthanli.me/&quot;&gt;fasterthanli.me&lt;/a&gt;, 2021)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://endler.dev/2020/rust-compile-times/&quot;&gt;Tips for Faster Rust Builds&lt;/a&gt; (&lt;a href=&quot;https://endler.dev&quot;&gt;endler.dev&lt;/a&gt;, 2020-2022)
    &lt;ul&gt;
      &lt;li&gt;W rzeczywistości, wówczas nie czytałem tego artykułu, ale przeczytałem kiedy napisałem ten artykuł.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;szczegóły-projektu&quot;&gt;Szczegóły projektu&lt;/h1&gt;

&lt;p&gt;Oto jak duży był mój projekt &lt;a href=&quot;https://github.com/arxanas/git-branchless&quot;&gt;git-branchless&lt;/a&gt; przed pull request:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git-branchless/src&lt;/code&gt;: 12060 linii.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git-branchless/tests&lt;/code&gt;: 12897 linii.
    &lt;ul&gt;
      &lt;li&gt;Zauważ, że w dużej mierze opiera się na “snapshot testing”, więc większość tych linii kodu to “multiline string literals”.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git-branchless-lib/src&lt;/code&gt;: 12406 linii.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dopuszczalne są długie czasy kompilacji i łączenia [ang. “linking”], ale aby zoptymalizować sprzężenie zwrotnego programowania, potrzebuję szybkich czasów testowania. W szczególności chcę iterować nad pracowaniem pewnego testu. (&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ&lt;/a&gt; ma fajną funkcję automatycznego ponownego uruchamiania danego testu, gdy występuje zmiana w kodu źródła ale trwanie zbyt długo ponownej kompilacji zmniejsza jej przydatność.)&lt;/p&gt;

&lt;p&gt;Na początek zbudowanie binary &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_amend&lt;/code&gt; (który testuje subcommand &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;amend&lt;/code&gt;) po dodaniu pojedynczego komentarza do jego pliku testu (bez zmian w library!) wymaga ~6.9sek:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hyperfine &lt;span class=&quot;nt&quot;&gt;--warmup&lt;/span&gt; 3 &lt;span class=&quot;nt&quot;&gt;--prepare&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;echo &quot;// @nocommit test&quot; &amp;gt;&amp;gt;git-branchless/tests/command/test_amend.rs&apos;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cargo test --test mod --no-run&apos;&lt;/span&gt;   
Benchmark 1: cargo &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--test&lt;/span&gt; mod &lt;span class=&quot;nt&quot;&gt;--no-run&lt;/span&gt;
  Time &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mean ± σ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:      6.927 s ±  0.123 s    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;User: 7.652 s, System: 1.738 s]
  Range &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;min … max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:    6.754 s …  7.161 s    10 runs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tragedia! To nie duży projekt, a zmieniamy tylko testy, więc nie powinno to wymagać tak długiego czasu iteracji.&lt;/p&gt;

&lt;h1 id=&quot;podzielenie-się-na-więcej-crates&quot;&gt;Podzielenie się na więcej crates&lt;/h1&gt;

&lt;p&gt;W pull request wyodrębniłem do dodatkowych dziewięciu crates, co daje przyrostowy czas kompilacji testu wynoszący ~1.7sek (~4x poprawa).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hyperfine &lt;span class=&quot;nt&quot;&gt;--warmup&lt;/span&gt; 3 &lt;span class=&quot;nt&quot;&gt;--prepare&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;echo &quot;// @nocommit test&quot; &amp;gt;&amp;gt;git-branchless/tests/test_amend.rs&apos;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cargo test --test test_amend --no-run&apos;&lt;/span&gt;   
Benchmark 1: cargo &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--test&lt;/span&gt; test_amend &lt;span class=&quot;nt&quot;&gt;--no-run&lt;/span&gt;
  Time &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mean ± σ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:  	1.771 s ±  0.012 s	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;User: 1.471 s, System: 0.330 s]
  Range &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;min … max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:	1.750 s …  1.793 s	10 runs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jeśli chodzi o poprawę relatywną, to znaczna, ale jeśli chodzi o poprawę absolutną, sądzę, że jest raczej słaba. Bym oczekiwał 100-200ms na parsing, macro expansion, typechecking, i code generation (bez optimacji) dla pliku tego rozmiaru (~1k linii, głownie długi wartości łańcuchowe).&lt;/p&gt;

&lt;p&gt;Dodatkowe, dzielenie na wiele crates utrudnia rozpowszechnianie projektu za pośrednictwem &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Każdy crate wymaga indywidualnego publikowania na crates.io (nie można opublikować crate z zależnościami Git w crates.io).
    &lt;ul&gt;
      &lt;li&gt;Dlatego muszę zarządzać wersjami i licencji każdego crate.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Według mojej ankiety wśród użytkowników, większość moich użytkowników instaluje przez &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo&lt;/code&gt;. Na pytanie “Jak zainstalowałeś git-branchless?”, odpowiedzi są następujące (stan na ):
    &lt;ul&gt;
      &lt;li&gt;7/18 (38.9%): przez &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo install git-branchless&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;4/18 (22.2%): za pośrednictwem tradycyjnego systemowego menedżera pakietów.&lt;/li&gt;
      &lt;li&gt;4/18 (22.2%): przez Nix lub NixOS&lt;/li&gt;
      &lt;li&gt;2/18 (11.1%): klonując repozytorium i ręcznie budując i instalując.&lt;/li&gt;
      &lt;li&gt;1/18 (5.6%): przez artefakt kompilacji z GitHub Actions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Niestety, muszę publicznie udostępniać wewnętrzne moduły na crates.io tylko po to, aby uzyskać rozsądne czasy kompilacji.&lt;/p&gt;

&lt;h1 id=&quot;czas-bez-operacji&quot;&gt;Czas bez operacji&lt;/h1&gt;

&lt;p&gt;Wtedy, mierzę czas bez operacji [ang. “no-op”] na ~350ms dla mniejszej crate testowania z niewieloma zależności:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hyperfine &lt;span class=&quot;nt&quot;&gt;--warmup&lt;/span&gt; 3 &lt;span class=&quot;s1&quot;&gt;&apos;cargo test -p git-branchless-test --no-run&apos;&lt;/span&gt; 		 
Benchmark 1: cargo &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; git-branchless-test &lt;span class=&quot;nt&quot;&gt;--no-run&lt;/span&gt;
  Time &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mean ± σ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:     344.2 ms ±   3.5 ms    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;User: 246.2 ms, System: 91.9 ms]
  Range &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;min … max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:   340.4 ms … 351.0 ms    10 runs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To jest nieoczekiwane. Spodziewałbym się, że czas na kompilację bez operacji będzie podobny do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git status&lt;/code&gt;, może 15ms:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hyperfine &lt;span class=&quot;nt&quot;&gt;--warmup&lt;/span&gt; 3 &lt;span class=&quot;s1&quot;&gt;&apos;git status&apos;&lt;/span&gt;
Benchmark 1: git status
  Time &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mean ± σ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 	 13.5 ms ±   2.5 ms    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;User: 4.9 ms, System: 6.1 ms]
  Range &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;min … max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:    11.1 ms …  24.7 ms    197 runs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tu może być jakiś głębszy problem. Dokumentacji &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo nextest&lt;/code&gt; ostrzega, że niektóre systemy przeciw malware mogą wprowadzać sztuczne opóźnienie uruchamiania podczas sprawdzania plików wykonywalnych:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A typical sign of this happening is even the simplest of tests in cargo nextest run taking more than 0.2 seconds.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Zgodnie z dokumentacją, oznaczyłem moje oprogramowanie terminala jako “Developer Tools” w systemie macOS, ale nie udało mi się skrócić czasu kompilacji bez operacji.&lt;/p&gt;

&lt;h1 id=&quot;koniec-profilowania&quot;&gt;Koniec profilowania?&lt;/h1&gt;

&lt;p&gt;Spróbowalem z subcommand crate, który niedawno stworzyłem bez dużo zaleźności:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hyperfine &lt;span class=&quot;nt&quot;&gt;--warmup&lt;/span&gt; 3 &lt;span class=&quot;nt&quot;&gt;--prepare&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;echo &quot;// @nocommit test&quot; &amp;gt;&amp;gt;git-branchless-test/tests/test_test.rs&apos;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cargo test -p git-branchless-test --no-run&apos;&lt;/span&gt;
Benchmark 1: cargo &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; git-branchless-test &lt;span class=&quot;nt&quot;&gt;--no-run&lt;/span&gt;
  Time &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mean ± σ&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:  	1.855 s ±  0.034 s	&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;User: 1.476 s, System: 0.335 s]
  Range &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;min … max&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:	1.831 s …  1.939 s	10 runs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Wykres czasu kompilacji według &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo build&lt;/code&gt; nie pomaga. Tylko pokazuje to, że budowany test wymaga 100% czasu:&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
        &lt;a href=&quot;/assets/posts/rust-przyrostowe-czasy-testowania/cargo-timings-git-branchless-test-crate.png&quot;&gt;&lt;img class=&quot;center-image&quot; src=&quot;/assets/posts/rust-przyrostowe-czasy-testowania/cargo-timings-git-branchless-test-crate.png&quot; alt=&quot;The timing graph for building the `git-branchless-test` crate.&quot; title=&quot;The timing graph for building the `git-branchless-test` crate.&quot; /&gt;&lt;/a&gt;
        &lt;figcaption class=&quot;caption&quot;&gt;&lt;p&gt;The timing graph for building the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git-branchless-test&lt;/code&gt; crate.&lt;/p&gt;
&lt;/figcaption&gt;
      &lt;/figure&gt;

&lt;h1 id=&quot;koniec-kolejnych-pomysłów&quot;&gt;Koniec kolejnych pomysłów?&lt;/h1&gt;

&lt;p&gt;Oto niektóre pomysły, które nie zadziałały:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Połączenie testów integracyjnych w jeden binary. (W każdym razie chętnie uruchamiam indywidualne binaries, jeśli to konieczne.)&lt;/li&gt;
  &lt;li&gt;Zmniejszenie głównych monomorfozacji (wywołania &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AsRef&lt;/code&gt; itp. Pojawiły się w &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo llvm-lines&lt;/code&gt;, ale ich zmniejszenie nie wydawało się poprawę czasu kompilacji).&lt;/li&gt;
  &lt;li&gt;Używanie &lt;a href=&quot;https://github.com/mozilla/sccache&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sccache&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Używanie &lt;a href=&quot;https://nexte.st/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo nextest&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Używanie &lt;a href=&quot;https://github.com/michaeleisel/zld&quot;&gt;zld&lt;/a&gt;/&lt;a href=&quot;https://github.com/rui314/mold&quot;&gt;mold&lt;/a&gt;/&lt;a href=&quot;https://github.com/bluewhalesystems/sold&quot;&gt;sold&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Ustawienie &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.dev.split-debuginfo = “unpacked”&lt;/code&gt; (dla systemu macOS).&lt;/li&gt;
  &lt;li&gt;Ustawienie &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.dev.build-override.opt-level = 3&lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;Niestety, są dużo makr proceduralnych, zwłaszcza &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[instrument]&lt;/code&gt; z crate &lt;a href=&quot;https://docs.rs/tracing/latest/tracing/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracing&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ustawienie &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.dev.debug = 0&lt;/code&gt;. W rzeczywistości skraca czas kompilacji o 20ms, ale samo w sobie nie wystarczy.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Więc teraz utknąłem. To najwięcej, co mogę skrócić przyrostowe czasy testowania Rust. Daj znać, jeśli masz jakieś inne pomysły.&lt;/p&gt;

&lt;h2 id=&quot;komentarze&quot;&gt;Komentarze&lt;/h2&gt;

&lt;ul&gt;



&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/github-comment-links.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = &quot;https://blog.waleedkhan.name/pl/rust-przyrostowe-czasy-testowania/&quot;;
    this.page.identifier = &quot;rust-przyrostowe-czasy-testowania/&quot;;
};

(function() { // DON&apos;T EDIT BELOW THIS LINE
    var d = document, s = d.createElement(&apos;script&apos;);
    s.src = &apos;//waleedkhan-name.disqus.com/embed.js&apos;;
    s.setAttribute(&apos;data-timestamp&apos;, +new Date());
    (d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

</description>
        <pubDate>Tue, 07 Feb 2023 00:00:00 -0600</pubDate>
        <link>https://blog.waleedkhan.name/pl/rust-przyrostowe-czasy-testowania/</link>
        <guid isPermaLink="true">https://blog.waleedkhan.name/pl/rust-przyrostowe-czasy-testowania/</guid>
        
        <category>rust</category>
        
        <category>software-engineering</category>
        
        
      </item>
    
      <item>
        <title>System kontroli wersja Yandex Arc</title>
        <description>&lt;p&gt;&lt;em&gt;Docelowi odbiorcy: deweloperzy systemów kontroli źródła, tak jak Git i Mercurial.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ostatnio był przeciek koda z &lt;a href=&quot;https://pl.wikipedia.org/wiki/Yandex&quot;&gt;Yandex&lt;/a&gt;. Ja nie spradzałem plików, ale temat właśnie przypomina nam, że Yandex utrzymuje swoje duże &lt;a href=&quot;https://monorepo.tools/&quot;&gt;monorepo&lt;/a&gt;, a nawet zbudował własny &lt;a href=&quot;https://pl.wikipedia.org/wiki/System_kontroli_wersji&quot;&gt;system kontroli źródła&lt;/a&gt; [ang. “source control system”], żeby sobie z tym radzić, o nazwie “Arc”.&lt;/p&gt;

&lt;p&gt;Oryginalny artykuł z Yandex (2020): &lt;a href=&quot;https://habr.com/ru/company/yandex/blog/482926/&quot;&gt;https://habr.com/ru/company/yandex/blog/482926/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Krótkie notatki (pierwotnie opublikowane na &lt;a href=&quot;https://discord.com/channels/1042895022950994071/1042907270473850890/1068630001240514691&quot;&gt;Discordzie&lt;/a&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wydaje się, że jest oparty nad &lt;a href=&quot;https://subversion.apache.org/&quot;&gt;SVN&lt;/a&gt; na back-end.&lt;/li&gt;
  &lt;li&gt;Prowadzają &lt;a href=&quot;https://trunkbaseddevelopment.com/&quot;&gt;trunk-based development&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;6 mln zatwierdzeń, 2 mln plików, 2TB rozmiar repo.&lt;/li&gt;
  &lt;li&gt;Wypróbowali &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;, ale nie rozwiązał problemów wydajności.&lt;/li&gt;
  &lt;li&gt;Używają numery generacji [ang. “generation numbers”] do obliczania “merge-bases”.
    &lt;ul&gt;
      &lt;li&gt;Jest to teraz dostępne w Gitu poprzez &lt;a href=&quot;https://git-scm.com/docs/commit-graph&quot;&gt;mechanizm commit-graph&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prawdopodobnie oparty nad Gitem do front-end UI, ale narzekają, że UI Gita jest zły, więc go ulepszają.&lt;/li&gt;
  &lt;li&gt;Używany wewnętrznie przez 20% deweloperzy w momencie napisania.&lt;/li&gt;
  &lt;li&gt;Ciężko używa &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_file_system&quot;&gt;wirtualnego system plików&lt;/a&gt; [ang. “virtual filesystem”, “VFS”].
    &lt;ul&gt;
      &lt;li&gt;Używają &lt;a href=&quot;https://en.wikipedia.org/wiki/Filesystem_in_Userspace&quot;&gt;FUSE&lt;/a&gt; na macOS, chociaż wsparcie VFS’ów na macOS jest niestabilne w tym czasie; może zmienili od tamtego czasu?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Używa &lt;a href=&quot;https://cloud.yandex.com/en/services/ydb&quot;&gt;Yandex Database&lt;/a&gt; (YDB) jako bazę danych na back-end, z jakimś narzędziem przekładania z SVN’a.&lt;/li&gt;
  &lt;li&gt;W ramach systemu code review, zatwierdzenie Arc’a będzie przedkładane w zatwierdzenie SVN’a, w tym dodatkowe metadane z Arc’a.&lt;/li&gt;
  &lt;li&gt;Niezauważalnie używa zatwierdzenia dla “working copy” aby przeprowadzać niektóre algorytmy, który zawierać “untracked” pliki, ponieważ zaopatrzywa VFS.
    &lt;ul&gt;
      &lt;li&gt;Wspomniałem o tym w kontekście &lt;a href=&quot;https://github.com/martinvonz/jj&quot;&gt;Jujutsu VCS&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;W sumie, nie wydaje mi się, że ma wiele do awansowania systemów kontroli wersji w porównaniu z dużymi firmami tech, takimi jak Google i Meta.&lt;/p&gt;

&lt;h2 id=&quot;komentarze&quot;&gt;Komentarze&lt;/h2&gt;

&lt;ul&gt;



&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/github-comment-links.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = &quot;https://blog.waleedkhan.name/pl/yandex-arc/&quot;;
    this.page.identifier = &quot;yandex-arc/&quot;;
};

(function() { // DON&apos;T EDIT BELOW THIS LINE
    var d = document, s = d.createElement(&apos;script&apos;);
    s.src = &apos;//waleedkhan-name.disqus.com/embed.js&apos;;
    s.setAttribute(&apos;data-timestamp&apos;, +new Date());
    (d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

</description>
        <pubDate>Fri, 27 Jan 2023 00:00:00 -0600</pubDate>
        <link>https://blog.waleedkhan.name/pl/yandex-arc/</link>
        <guid isPermaLink="true">https://blog.waleedkhan.name/pl/yandex-arc/</guid>
        
        <category>git</category>
        
        <category>software-engineering</category>
        
        
      </item>
    
      <item>
        <title>Używanie `tracing` w aplikacji Rust CLI</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#dla-cargo&quot; id=&quot;markdown-toc-dla-cargo&quot;&gt;Dla Cargo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#pełne-notatki&quot; id=&quot;markdown-toc-pełne-notatki&quot;&gt;Pełne notatki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#komentarze&quot; id=&quot;markdown-toc-komentarze&quot;&gt;Komentarze&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/epage&quot;&gt;@epage&lt;/a&gt; w &lt;a href=&quot;https://github.com/arxanas/git-branchless/discussions/732&quot;&gt;https://github.com/arxanas/git-branchless/discussions/732&lt;/a&gt; zapytał:&lt;/p&gt;

 	Widzę, że mówią o &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracing&lt;/code&gt;, ale głównie z perspektywy “web” i jestem ciekawy, jak to doświadczenie przekłada się na CLI. Zamierzam zastosować go w niektórych mniejszych CLI, żeby zdobyć trochę doświadczenia, aby zrozumieć, w jaki sposób może pomóc &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cargo&lt;/code&gt;.

&lt;p&gt;Ponownie publikuję moją odpowiedź tutaj, &lt;a href=&quot;https://blog.waleedkhan.name/on-bullet-points/&quot;&gt;w formie wypunktowanej&lt;/a&gt;:&lt;/p&gt;

&lt;h2 id=&quot;dla-cargo&quot;&gt;Dla Cargo&lt;/h2&gt;

&lt;p&gt;W przypadku Cargo chciałbym podkreślić następujące punkty:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zachęca do robienia właściwych rzeczy za pomocą makr do ustrukturyzowanego logowania [ang. “structured logging”]. Dodatkowe obliczenia nie są przeprowadzane, jeśli nie zostaną używane przez subskrybenta, co w przeciwnym razie mogłoby spowodować regres wydajności.&lt;/li&gt;
  &lt;li&gt;Śledzenie “spantraces” w celu profilowania jest niewygodne, ponieważ trzeba ręcznie dodawać adnotacje do każdej funkcji, która ma być śledzona. Nie wiem, czy można to poprawić za pomocą “stack traces”.&lt;/li&gt;
  &lt;li&gt;Można łatwo wysyłać dane do wielu różnych subskrybentów, w tym do niestandardowych (…jeśli wiadomo, jakie funkcje wywołać). Na przykład, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracing_subscriber::fmt_layer::Layer::with_writer&lt;/code&gt; pozwala zbudować warstwę, która zużywa sformatowane informacje logowania i zapisuje je w dowolnym miejscu.
    &lt;ul&gt;
      &lt;li&gt;Można używać gotowych komponentów, takich jak subskrybent śledzenia Chrome [ang. “Chrome tracing”, jakaś].&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ktoś może to skonfigurować raz, a inni nie muszą się tym zbytnio przejmować.&lt;/li&gt;
  &lt;li&gt;Dla mnie, profilowanie okazało się bardzo skuteczne.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pełne-notatki&quot;&gt;Pełne notatki&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Przez używanie &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eyre&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color_eyre&lt;/code&gt; można dołączyć parametry funkcji do “spantraces”. Jest to dość cenne podczas debugowania, ponieważ widzę m.in. OID zatwierdzenia [ang. “commit OID”] w “spantrace” dla zatwierdzenia, które powoduje problemy, bez konieczności ręcznego wyodrębniania go przez dodanie większej liczby logów.&lt;/li&gt;
  &lt;li&gt;Konfigurowanie &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracing&lt;/code&gt; po raz pierwszy jest uciążliwe, ale po tym w dużej mierze nie musisz go dotykać.
    &lt;ul&gt;
      &lt;li&gt;Oto moja funkcja, która to robi: &lt;a href=&quot;https://github.com/arxanas/git-branchless/blob/4b76af669258e80a6f6eb4ddf45bbb358da80248/git-branchless/src/commands/mod.rs#L437&quot;&gt;https://github.com/arxanas/git-branchless/blob/4b76af669258e80a6f6eb4ddf45bbb358da80248/git-branchless/src/commands/mod.rs#L437&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Z powodzeniem skonfigurowałem instrukcje logowania do drukowania za pomocą mojego własnego typu (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Effects&lt;/code&gt;), zamiast drukowania bezpośrednio na stdout/stderr, ponieważ może to blokować liczniki postępu [ang. “progress meters”] lub inne interaktywnie dane wyjście.&lt;/li&gt;
      &lt;li&gt;Skonfigurowałem go tak, że podprocesy nie zostaną zawarte w śledzeniu nadrzędnym; otrzymują własne pliki wyjściowe. Szczerze mówiąc, nie sądzę, żebym musiał badać śledzenie podprocesów.&lt;/li&gt;
      &lt;li&gt;Kiedyś było to mniej ergonomiczne, ale ostatnio ulepszyli coś związanego z kompozycją warstw, na przykład filtrowanie jednej warstwy na podstawie innej warstwy; zobacz &lt;a href=&quot;https://github.com/arxanas/git-branchless/commit/5428f1b9dbed356accf854774cad053c22d19b1f&quot;&gt;https://github.com/arxanas/git-branchless/commit/5428f1b9dbed356accf854774cad053c22d19b1f&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Niektóre komunikaty o błędach dotyczące kompozycji warstw mogą być nieczytelne z powodu domyślnego użycia polimorfizmu statycznego. Na przykład trudno jest warunkowo skonstruować warstwę do włączenia. Typy stają się bardzo długimi łańcuchami zagnieżdżonych parametrów typu ogólnego [ang. “generic type parameters”].
        &lt;ul&gt;
          &lt;li&gt;Na szczęście &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&amp;lt;Layer&amp;gt;&lt;/code&gt; jest również warstwą, więc możesz przekazać &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Some(layer)&lt;/code&gt; lub &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt; w zależności od stosownego warunku, zamiast próbować bezpośrednio wywoływać metody rejestru.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Makro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#[instrument]&lt;/code&gt; to jedyny realistyczny sposób dołączania funkcji do “spantraces” dla &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eyre&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color_eyre&lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;Niszczy to autopoprawki [ang. “autofixes”, tak jak w IDE] (prawdopodobnie należy to uznać za błąd w &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rust-analyzer&lt;/code&gt;).&lt;/li&gt;
      &lt;li&gt;Może to wymazać lokalizację błędów, ponieważ czasami błąd jest przypisywany do funkcji jako całości, a nie do konkretnej linii.&lt;/li&gt;
      &lt;li&gt;Może to wydłużyć czas kompilacji, ponieważ jest to makro proceduralne [ang. “procedural macro”, &lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html&quot;&gt;pojęcia z Rusta&lt;/a&gt;]. Jak być może wiesz, procedury makr proceduralnych, takie jak &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syn&lt;/code&gt; [ang. &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;Rust crate zwany “syn”&lt;/a&gt;, nie ma czegoś wspólnego z słowem “syn”], zwykle znajdują się na ścieżce krytycznej [ang. “critical path”] kompilacji, ale jeśli zobowiążesz się w ogóle nie używać makr proceduralnych, możesz je pominąć.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Profilowanie poprzez zrzut do warstwy śledzenia Chrome jest skuteczne.
    &lt;ul&gt;
      &lt;li&gt;Spójrz na &lt;a href=&quot;https://github.com/arxanas/git-branchless/wiki/Runbook#profiling&quot;&gt;https://github.com/arxanas/git-branchless/wiki/Runbook#profiling&lt;/a&gt;, aby uzyskać szczegółowe informacje na temat procedur profilowania.&lt;/li&gt;
      &lt;li&gt;Wielokrotnie korzystałem z tego systemu do debugowania problemów/regresji w związku wydajnością. Istniejące wizualizatory śledzenia Chrome są całkiem przydatne do analizy podziału spędzonego czasu.&lt;/li&gt;
      &lt;li&gt;Zawarcie parametrów funkcji było wyjątkowo przydatne, ponieważ mogłem bezpośrednio zobaczyć wycinek danych wyjściowych profilowania, który trwał zbyt długo, i sprawdzić odpowiedni OID zatwierdzenia, dzięki czemu mogłem zbadać i przetestować to konkretne zatwierdzenie.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spróbowałem użyć śledzenia jako danych wejściowych do mojego własnego systemu raportowania postępów (tak, aby wywołania funkcji były bezpośrednio powiązane z paskami postępu, które pojawiają się na ekranie). Było to możliwe, ale ostatecznie zrezygnowałem z tego podejścia, ponieważ operacje logiczne nie odpowiadały dokładnie jeden do jednego wywołaniom funkcji, a zbyt łatwo było zapomnieć o poprawnym opatrzeniu metodą adnotacją.&lt;/li&gt;
  &lt;li&gt;W ogóle nie próbowałem śledzenia z async/.await.&lt;/li&gt;
  &lt;li&gt;W ogóle nie próbowałem &lt;a href=&quot;https://github.com/tokio-rs/console&quot;&gt;https://github.com/tokio-rs/console&lt;/a&gt;, ale chciałbym wiedzieć, czy jest to dla Was przydatne.&lt;/li&gt;
  &lt;li&gt;Ustrukturyzowane logowanie jest świetne.
    &lt;ul&gt;
      &lt;li&gt;Samo użycie makr ustrukturyzowanego logowania z reprezentacjami debugowania (np. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;warn(?var, &quot;Message&quot;)&lt;/code&gt;) jest znacznie bardziej ergonomiczne niż ręczne interpolowanie wartości do stringów.&lt;/li&gt;
      &lt;li&gt;Obsługuje również takie rzeczy, jak renderowanie znaków niedrukowalnych, gdzie wcześniej musiałbym uważać, aby uwzględnić wartości stringów w cudzysłowach itp.&lt;/li&gt;
      &lt;li&gt;Zasadniczo można zobaczyć te zdarzenia i ich wartości w wynikach profilowania, chociaż nie musiałem profilować na podstawie pojedynczych zdarzeń, tylko na podstawie całego zakresu.&lt;/li&gt;
      &lt;li&gt;Jest to bardziej wydajne, ponieważ nie będziemy budować sznurów, jeśli wartości nie zostaną zużyte przez żadnego subskrybenta w czasie wykonywania.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Istnieje dziwna niezgodność między wersją &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tracing_subscriber&lt;/code&gt; używaną przez mój kod i &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color_eyre&lt;/code&gt;, co oznacza, że ​​zablokowałem ją w znanej dobrej wersji tutaj: &lt;a href=&quot;https://github.com/arxanas/git-branchless/pull/533/&quot;&gt;https://github.com/arxanas/git-branchless/pull/533/ zatwierdzenia/e97954a9a9fab4039ad269d6b8982bb8bd95b133&lt;/a&gt;.
    &lt;ul&gt;
      &lt;li&gt;Myślę, że &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color_eyre&lt;/code&gt; musi po prostu zaktualizować swoją wersję śledzenia-subskrybenta, ale od tamtej pory się tym nie zajmowałem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;komentarze&quot;&gt;Komentarze&lt;/h2&gt;

&lt;ul&gt;



&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/github-comment-links.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = &quot;https://blog.waleedkhan.name/pl/śledzenie-aplikacji-rust-cli/&quot;;
    this.page.identifier = &quot;śledzenie-aplikacji-rust-cli/&quot;;
};

(function() { // DON&apos;T EDIT BELOW THIS LINE
    var d = document, s = d.createElement(&apos;script&apos;);
    s.src = &apos;//waleedkhan-name.disqus.com/embed.js&apos;;
    s.setAttribute(&apos;data-timestamp&apos;, +new Date());
    (d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

</description>
        <pubDate>Wed, 25 Jan 2023 00:00:00 -0600</pubDate>
        <link>https://blog.waleedkhan.name/pl/śledzenie-aplikacji-rust-cli/</link>
        <guid isPermaLink="true">https://blog.waleedkhan.name/pl/śledzenie-aplikacji-rust-cli/</guid>
        
        <category>rust</category>
        
        <category>software-engineering</category>
        
        
      </item>
    
      <item>
        <title>Interaktywne blogi</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#niech-żyje-ten-blog&quot; id=&quot;markdown-toc-niech-żyje-ten-blog&quot;&gt;Niech żyje ten blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#komentarze&quot; id=&quot;markdown-toc-komentarze&quot;&gt;Komentarze&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dla mnie, najlepszym platformą na blogging jest &lt;a href=&quot;https://www.google.com/docs&quot;&gt;Google Docs&lt;/a&gt;, bo obsługuje poniższe:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Współpracować na żywo.&lt;/li&gt;
  &lt;li&gt;Pozostawiać komentarze bezpośrednio w tekście, a nie w ograniczonym obszarze.&lt;/li&gt;
  &lt;li&gt;Sugerować zmiany bezpośrednio w tekście. Cóż miły sposób na poprawianie tekstu!
    &lt;ul&gt;
      &lt;li&gt;Z tego powodu również wolę Wikis od Git’a, jeśli chodzi o pisanie dokumentacji, bo bariera wejścia jest znacznie mniejsza.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Niestety, Google Docs nie jest zwłaszcza dostępny:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wydaje się, że nie będzie indeksowany przez wyszukiwarki?&lt;/li&gt;
  &lt;li&gt;Wymaga Javascript.&lt;/li&gt;
  &lt;li&gt;Wymaga Google, czemu niektórzy ludzie sprzeciwiają się ze względu na prywatność.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dlatego nie wydaję w ten sposób postów na blogu.&lt;/p&gt;

&lt;style type=&quot;text/css&quot;&gt;
@keyframes hypermedia {
  0%, 100% {
    left: -1em;
    top: 0.4em;
    z-index: 1;
    font-size: normal;
  }
  
  25% {
    font-size: 1.3em;
  }
  
  75% {
    font-size: 0.7em;
  }

  50% {
    left: 97%;
    top: -0.6em;
    z-index: 1;
    font-size: normal;
  }
  
  51%, 99% {
    z-index: -1;
  }
}

.hypermedia {
  letter-spacing: 0.1em;
  position: relative;
  font-variant: small-caps;
}

.hypermedia::before {
  content: &quot;✨&quot;;
  position: absolute;
  animation-name: hypermedia;
  animation-duration: 6s;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
}
&lt;/style&gt;

&lt;p&gt;Ale w dobie &lt;span class=&quot;hypermedia&quot;&gt;hipermediów&lt;/span&gt; te funkcje powinny być standardem! Powinniśmy &lt;span class=&quot;hypermedia&quot;&gt;dyskutować&lt;/span&gt;, a nie wyrzucać artykuły &lt;span class=&quot;hypermedia&quot;&gt;w próżnię&lt;/span&gt;!&lt;/p&gt;

&lt;p&gt;Medium wyświetlało komentarze w tekście, ale &lt;a href=&quot;https://medium.com/@jashan/how-to-make-the-best-of-a-broken-commenting-system-113c8cc1fe71&quot;&gt;już tego nie robi&lt;/a&gt; (nie żebym chciał wydawać posty na Medium). Nie widziałem wielu innych blogów, które zapraszają do dyskusji za pomocą interaktywnych funkcji.&lt;/p&gt;

&lt;p&gt;Kiedyś czytałem &lt;em&gt;&lt;a href=&quot;https://dev.realworldocaml.org/&quot;&gt;Real World OCaml&lt;/a&gt;&lt;/em&gt;, kiedy jego drugie wydanie było w wersji roboczej. Po każdym zdaniu znajdował się link na pozostawianie komentarza. To jest naprawdę fajny sposób na pisanie książki! Dlaczego akurat książka jest bardziej interaktywna niż nasze blogi?&lt;/p&gt;

&lt;h2 id=&quot;niech-żyje-ten-blog&quot;&gt;Niech żyje ten blog&lt;/h2&gt;

&lt;p&gt;Od niedawna można pozostawiać komentarze na akapitach mojego blogu, najeżdżając/dotykając i klikając link “Skomentuj”, który się pojawi.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Inne rozwiązania:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://utteranc.es&quot;&gt;https://utteranc.es&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;Używany już do komentarzy na tym blogu, chociaż jest trochę podejrzany, jeśli chodzi o korzystanie plików cookie.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Każda z tych opcji wymaga tworzenie własnego wątku komentarza dla każdego akapitu, na którym można skomentować.
        &lt;ul&gt;
          &lt;li&gt;Ich UIs nie zostały zaprojektowane tak, aby były zwarte, więc nie pasują dobrze między akapitami na blogu. Byłoby ogromny formularz po każdym akapitu.&lt;/li&gt;
          &lt;li&gt;Spowodowałoby to niepotrzebne obciążenie serwerów komentarzy, trochę niegrzecznie dla nich.&lt;/li&gt;
          &lt;li&gt;Spowodowałoby to wolniejsze ładowanie strony podczas zapytania do kilku wątków komentarzy.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Możesz czerpać inspirację z projektu takiego jak SideComments.js.&lt;/li&gt;
      &lt;li&gt;Moja implementacja niestety opiera się na GitHub jako dostawcy uwierzytelniania i bazie danych. Jestem pewien, że wielu czytelników nie będzie miało kont GitHub’a.
        &lt;ul&gt;
          &lt;li&gt;To był dla mnie najłatwiejszy sposób na zaimplementowanie.&lt;/li&gt;
          &lt;li&gt;GitHub API jest wystarczająco wyrazisty, aby wysłać zapytanie o wszystkie komentarze dla pewnego dokumentu w jednym żądaniu.&lt;/li&gt;
          &lt;li&gt;GitHub API nie wymaga uwierzytelniania ani klucza API do wysyłania żądań!
            &lt;ul&gt;
              &lt;li&gt;Przypuszczalnie będziesz ograniczany bardziej agresywnie niż w przypadku uwierzytelnienia.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Otwarcie nowej strony GitHub Issues’a w celu pozostawiania komentarza jest niewygodnie.&lt;/li&gt;
          &lt;li&gt;Patrząc wstecz, być może powinienem był użyć GitHub Discussions’a zamiast GitHub Issues’a jako bazy daty, ponieważ są to… dyskusje.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Akapity są identyfikowane za pomocą permalinku/”slug” i poprzez pobranie kilku pierwszych znormalizowanych bajtów danych w akapicie i zakodowanie jako base64.
        &lt;ul&gt;
          &lt;li&gt;Teoretycznie identyfikatory akapitów nie są zatem stabilne, jeśli treść zmienia się później, ale wydaje się, że jest to niewielki problem.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Oto implementacja w momencie pisania tego tekstu (137 linii kodu): &lt;a href=&quot;https://github.com/arxanas/blog/blob/c34f0e18b81ed1d1b22636eaef2cabe7b6afd77e/scripts/github-comment-links.js&quot;&gt;github-comment-links.js&lt;/a&gt;.
        &lt;ul&gt;
          &lt;li&gt;Nowoczesne API przeglądarki sprawiają, że zapytanie do API GitHub’a jest dość proste.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;komentarze&quot;&gt;Komentarze&lt;/h2&gt;

&lt;ul&gt;



&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/github-comment-links.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = &quot;https://blog.waleedkhan.name/pl/interaktywne-blogi/&quot;;
    this.page.identifier = &quot;interaktywne-blogi/&quot;;
};

(function() { // DON&apos;T EDIT BELOW THIS LINE
    var d = document, s = d.createElement(&apos;script&apos;);
    s.src = &apos;//waleedkhan-name.disqus.com/embed.js&apos;;
    s.setAttribute(&apos;data-timestamp&apos;, +new Date());
    (d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

</description>
        <pubDate>Wed, 11 Jan 2023 00:00:00 -0600</pubDate>
        <link>https://blog.waleedkhan.name/pl/interaktywne-blogi/</link>
        <guid isPermaLink="true">https://blog.waleedkhan.name/pl/interaktywne-blogi/</guid>
        
        <category>rant</category>
        
        <category>writing</category>
        
        
      </item>
    
      <item>
        <title>Gdzie są moje funkcji Git’a z przyszłości?</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#git-jest-do-bani&quot; id=&quot;markdown-toc-git-jest-do-bani&quot;&gt;Git jest do bani&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rubryka&quot; id=&quot;markdown-toc-rubryka&quot;&gt;Rubryka&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#klienty&quot; id=&quot;markdown-toc-klienty&quot;&gt;Klienty&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#wyróżnienia&quot; id=&quot;markdown-toc-wyróżnienia&quot;&gt;Wyróżnienia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#komentarze&quot; id=&quot;markdown-toc-komentarze&quot;&gt;Komentarze&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;git-jest-do-bani&quot;&gt;Git jest do bani&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;System kontroli wersji “Git”&lt;/a&gt; od 15+ lat przynosi nam nieszczęście. Od momentu powstania, tysiące osób próbowało stworzyć nowe klienty Git’a aby poprawić jego użyteczność.&lt;/p&gt;

&lt;p&gt;Jednak, prawie każda z nich skupiła się budować ładną fasadę nad Git’em, żeby robić te same operacji, które właśnie robi Git, jakby interfejs linii komend Git’a był szczytem użyteczności.&lt;/p&gt;

&lt;p&gt;Nikt nie raczy się zastanowić: jakie są &lt;em&gt;przepływy pracy&lt;/em&gt;, które osoby właśnie chcą wykonywać? Jakie są &lt;em&gt;funkcji&lt;/em&gt;, ułatwiające takie przepływy pracy? Zamiast, dostajemy klienty, które uważają, że &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git rebase -i&lt;/code&gt; to najlepszy sposób, aby zmienić komunikat zatwierdzenia, aby edytować zatwierdzenie, aby rozdzielić zatwierdzenie — albo, że warto nawet pokazać w UI tę funkcję.&lt;/p&gt;

&lt;h2 id=&quot;rubryka&quot;&gt;Rubryka&lt;/h2&gt;

&lt;p&gt;Rozmyślałem o przepływach pracy, które często wykonuję, i sprawdziłem kilka klientów Git’a (niektóre z nich są GUIs, i niektóre TUIs), żebym zrozumiał, jak dobrze je obsługują.&lt;/p&gt;

&lt;p&gt;Wielu z moich czytelników nie dba o tych przepływach pracy, ale to nie tylko sprawa samych przepływach pracy; chodzi o decyzję, by nie używać wadliwych prymitywnych oferowanych przez Git.&lt;/p&gt;

&lt;p&gt;Przepływy pracy:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reword&lt;/code&gt;&lt;/strong&gt;: Trzeba być możliwe aktualizować komunikat zatwierdzenia, który nie jest wypożyczany.
    &lt;ul&gt;
      &lt;li&gt;Aktualizowanie komunikatu zatwierdzenia nie spowoduje konfliktu scalania, zatem nie jest potrzebny wymagać, że zatwierdzenie jest wypożyczany.&lt;/li&gt;
      &lt;li&gt;Też powinno być możliwe aktualizować komunikat zatwierdzenia, który jest przodkiem wielu gałęzi, bez porzucania niektórych z tych gałęzi, ale nie róbmy sobie nadziei…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync&lt;/code&gt;&lt;/strong&gt;: Trzeba być możliwe synchronizować wszystkie moje gałęzi (albo dowolny podzbiór) przez scalanie lub zmianę bazy [ang. “rebase”], w jednej operacji!
    &lt;ul&gt;
      &lt;li&gt;Robię to cały czas! Praktycznie pierwsza rzecz każdego ranka przychodząc do pracy.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split&lt;/code&gt;&lt;/strong&gt;: Trzeba być szczególne polecenie, aby dzielić zatwierdzenie na dwa lub więcej zatwierdzeń, w tym zatwierdzenia, które nie są aktualnie wypożyczane.
    &lt;ul&gt;
      &lt;li&gt;Dzielenie zatwierdzenia nie spowoduje konfliktu scalania, zatem nie jest potrzebny wymagać, że zatwierdzenie jest wypożyczany.&lt;/li&gt;
      &lt;li&gt;Nie akceptuję rozwiązań za pomocą &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git rebase -i&lt;/code&gt;, ponieważ sprawdzanie stanu repozytorium podczas zmiany bazy jest bardzo mylące.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preview&lt;/code&gt;&lt;/strong&gt;: Przed wykonaniem scalania albo zmianą bazy, trzeba być możliwy podgląd wyniku, w tym ewentualne konflikty.
    &lt;ul&gt;
      &lt;li&gt;W ten sposób, nie muszę rozpoczynać scalania/zmiany bazy, żeby zobaczyć, czy się powiedzie, albo czy będzie trudno mi rozwiązać konflikty.&lt;/li&gt;
      &lt;li&gt;Konfliktami scalania może są najokropniejsza rzecz w używaniu Git’a, dlatego powinno być bardzo łatwiej zajmować się nimi (albo unikać zajmowania się nimi!).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt;&lt;/strong&gt;: Trzeba być możliwe cofnąć się z dowolnej operacji, najlepiej obejmujące śledzone-ale-niezatwierdzone zmiany.
    &lt;ul&gt;
      &lt;li&gt;To nie to samo, co cofnięcie [ang. “revert”] zatwierdzenia. Cofnięcie zatwierdzenia tworzy całkowicie nowe zatwierdzenie z odwrotnych zmian, ale cofnięcie operacji powinno przywrócić repozytorium do stanu, w jakim znajdowało się przed wykonaniem operacji, więc nie byłoby pierwotnego zatwierdzenia do przywrócenia.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;large-load&lt;/code&gt;&lt;/strong&gt;: UI powinien szybko ładować duże repozytorium.
    &lt;ul&gt;
      &lt;li&gt;UI nie powinien zawieszać się w żadnym momencie i powinien pokazywać przydatne informacje zaraz po załadowaniu. Nie powinieneś czekać na załadowanie całego repozytorium, zanim będziesz mógł sprawdzić zatwierdzenia i gałęzi.&lt;/li&gt;
      &lt;li&gt;Program może działać wolno przy pierwszym wywołaniu w celu zbudowania niezbędnych pamięci podręcznych, ale musi reagować szybko na kolejne wywołania.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;large-ops&lt;/code&gt;&lt;/strong&gt;: UI powinien reagować szybko podczas wykonywania różnych operacji, takich jak sprawdzanie zatwierdzeń i gałęzi, lub scalanie i zmianę bazy.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dodatkowe punkty:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Przyznam honorowe punkty ujemne każdemu klientowi, który ośmieli się potraktować git rebase -i tak, jakby był fundamentalnym prymitywem.&lt;/li&gt;
  &lt;li&gt;Przyznam honorowe punkty bonusowe każdemu klientowi, który wydaje się szanować empiryczne badania użyteczności dla Git (lub innych VCS).
    &lt;ul&gt;
      &lt;li&gt;Gitless:&lt;a href=&quot;https://gitless.com/&quot;&gt; https://gitless.com/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;IASGE:&lt;a href=&quot;https://investigating-archiving-git.gitlab.io/&quot;&gt; https://investigating-archiving-git.gitlab.io/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Z powodu, że nie zapisałem nic z tego, te kryteria są tylko po to, aby każdy sprzedawca tych klientów mógł wiedzieć, czy jestem pod wrażeniem, czy rozczarowany.&lt;/p&gt;

&lt;h2 id=&quot;klienty&quot;&gt;Klienty&lt;/h2&gt;

&lt;p&gt;Wybrałem arbitralnie kilku klientów z tej listy klientów. Z pewnością mylę się co do niektórych z tych punktów (lub zmieniły się od ostatniego razu), więc skomentuj.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Aktualizacja 2022-01-09: Dodałem IntelliJ.&lt;/li&gt;
  &lt;li&gt;Aktualizacja 2022-01-10: Dodałem Tower.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Załączyłem mój własny projekt git-branchless, ale się nie liczy jako przykład innowacji w branży. Tylko jest tu, aby pokazać, że wiele z tych przepływów pracy jest naprawdę możliwych.&lt;/p&gt;

&lt;style type=&quot;text/css&quot;&gt;
th.rotate {
  /* Something you can count on */
  height: 140px;
  white-space: nowrap;
}

th.rotate &gt; div {
  transform: 
    translate(20px, 51px) /* magic numbers */
    rotate(320deg);
  width: 30px;
}
th.rotate &gt; div &gt; span {
  padding: 5px 10px;
}

#data th:nth-child(even) &gt; div &gt; span, #data td:nth-child(even) {
  background-color: #eee;
}

&lt;/style&gt;

&lt;table id=&quot;data&quot;&gt;
&lt;thead&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git CLI&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;GitKraken&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://git-fork.com/&quot;&gt;Fork&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;Sourcetree&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.sublimemerge.com/&quot;&gt;Sublime Merge&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.syntevo.com/smartgit/&quot;&gt;SmartGit&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.git-tower.com/&quot;&gt;Tower&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://magit.vc/&quot;&gt;Magit&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/jesseduffield/lazygit&quot;&gt;Lazygit&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/extrawurst/gitui&quot;&gt;Gitui&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/arxanas/git-branchless&quot;&gt;git-branchless&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
    &lt;th class=&quot;rotate&quot;&gt;&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/martinvonz/jj&quot;&gt;Jujutsu&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;reword&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;❌&amp;nbsp;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;split&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;❌&amp;nbsp;&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;preview&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;4&lt;/sup&gt;&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;5&lt;/sup&gt;&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;6&lt;/sup&gt;&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;undo&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❓&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;⚠️&amp;nbsp;&lt;sup&gt;7&lt;/sup&gt;&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;large-load&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;8&lt;/sup&gt;&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;th&gt;&lt;code&gt;large-ops&lt;/code&gt;&lt;/th&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;8&lt;/sup&gt;&lt;/td&gt; &lt;!-- Git CLI --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- GitKraken --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Fork --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Sourcetree --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Sublime Merge --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- SmartGit --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- Tower --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- GitUp --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- IntelliJ --&gt;
    &lt;td&gt;✅&amp;nbsp;&lt;sup&gt;9&lt;/sup&gt;&lt;/td&gt; &lt;!-- Magit --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Lazygit --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- Gitui --&gt;
    &lt;td&gt;✅&lt;/td&gt; &lt;!-- git-branchless --&gt;
    &lt;td&gt;❌&lt;/td&gt; &lt;!-- jj --&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Uwagi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;sup&gt;1&lt;/sup&gt; Można to zrobić za pomocą &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git rebase -i&lt;/code&gt; lub odpowiednika, ale nie jest to ergonomiczne i działa tylko w przypadku zatwierdzeń osiągalnych z &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;, a nie z innych gałęzi.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;2&lt;/sup&gt; Zmiana komunikatu zatwierdzenia można wykonać bez wypożyczaniu zatwierdzenia, ale tylko na zatwierdzeń osiągalnych z &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;. Może istnieją dodatkowe ograniczenia.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;3&lt;/sup&gt; Częściowe wsparcie. Może pokazać, czy można przewijać scalanie do przodu, ale bez dodatkowych szczegołów.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;4&lt;/sup&gt; Można to robić za pomocą &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magit-merge-preview&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;5&lt;/sup&gt; Częściowe wsparcie. Jeśli operacja spowoduje konflikt scalania, i opcja &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--merge&lt;/code&gt; nie została przekazana, zamiast tego zostanie przerwana i pokaże liczbę plików w stanu konfliktu.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;6&lt;/sup&gt; Jujutsu nie pozwala na podgląd konfliktów scalania, ale scalanie i rebase zawsze się udają, a konflikty są przechowywane w zatwierdzeniu, a potem możesz cofnąć operację, jeśli nie chcesz zajmować się konfliktami scalania. W razie potrzeby możesz nawet przywrócić starą wersję zatwierdzenia po przeprowadzeniu scalania/zmiany bazy. Pozwala to uniknąć przerywania przepływu pracy, co jest ostatecznym celem tej funkcji, dlatego oceniam, że wystarczy dla tej kategorii.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;7&lt;/sup&gt; Obsługa cofania jest eksperymentalna i zależy na reflogu, który &lt;a href=&quot;https://github.com/arxanas/git-branchless/wiki/Architecture#comparison-with-the-reflog&quot;&gt;nie może cofnąć wszystkich rodzajów operacji&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;8&lt;/sup&gt; Git ma problemy z niektórymi operacjami na dużych repozytoriach i można je ulepszyć, ale uznamy to za podstawową wydajność dla dużych repozytoriów.&lt;/li&gt;
  &lt;li&gt;&lt;sup&gt;9&lt;/sup&gt; Chyba Magit ma taką samą wydajność jak Git, ale nie sprawdziłem, bo nie używam Emacs’a.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wyróżnienia&quot;&gt;Wyróżnienia&lt;/h2&gt;

&lt;p&gt;Pochwały:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GitUp: najbardziej innowacyjny GUI dla Git’a spośród powyższych.&lt;/li&gt;
  &lt;li&gt;GitKraken: wprowadza innowację w niektórych obszarach, takie jak ulepszona obsługa scentralizowanych przepływów pracy przez ostrzeganie o współbieżnie edytowanych plikach. Te obszary nie są napisane powyżej; Po prostu zauważyłem je przy innych okazjach.&lt;/li&gt;
  &lt;li&gt;Sublime Merge: niesamowicie responsywny, jak można się spodziewać po ludziach odpowiedzialnych za &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Tower: za przyjemną implementację cofania.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Wady:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fork: za utrudnienie wyszukiwania dokumentacji (bo “git fork undo” zazwyczaj produkuje wyniki cofania rozwidlenia w ogóle, a nie dla klienta Fork).&lt;/li&gt;
  &lt;li&gt;SmartGit: z braki we wszystkich testowanych kategoriach.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;komentarze&quot;&gt;Komentarze&lt;/h2&gt;

&lt;ul&gt;

&lt;li&gt;&lt;a class=&quot;icon-hacker-news&quot; href=&quot;https://news.ycombinator.com/item?id=34301543 &quot;&gt;Discussion on Hacker News&lt;/a&gt;&lt;/li&gt;


&lt;li&gt;&lt;a class=&quot;icon-lobsters&quot; href=&quot;https://lobste.rs/s/7tnnbq/where_are_my_git_ui_features_from_future &quot;&gt;Discussion on Lobsters&lt;/a&gt;&lt;/li&gt;


&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/github-comment-links.js&quot;&gt;&lt;/script&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = &quot;https://blog.waleedkhan.name/pl/git-ui-funkcji/&quot;;
    this.page.identifier = &quot;git-ui-funkcji/&quot;;
};

(function() { // DON&apos;T EDIT BELOW THIS LINE
    var d = document, s = d.createElement(&apos;script&apos;);
    s.src = &apos;//waleedkhan-name.disqus.com/embed.js&apos;;
    s.setAttribute(&apos;data-timestamp&apos;, +new Date());
    (d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

</description>
        <pubDate>Thu, 05 Jan 2023 00:00:00 -0600</pubDate>
        <link>https://blog.waleedkhan.name/pl/git-ui-funkcji/</link>
        <guid isPermaLink="true">https://blog.waleedkhan.name/pl/git-ui-funkcji/</guid>
        
        <category>git</category>
        
        <category>rant</category>
        
        <category>software-engineering</category>
        
        
      </item>
    
  </channel>
</rss>
