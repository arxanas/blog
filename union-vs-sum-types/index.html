<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Null-tracking, or the difference between union and sum types</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="https://waleedkhan.name/blog/union-vs-sum-types/">
  <link rel="alternate" type="application/rss+xml" title="Stenography and programming languages" href="https://waleedkhan.name/blog/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/blog/">Stenography and programming languages</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/blog/about/">About</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Null-tracking, or the difference between union and sum types</h1>
    <p class="post-meta"><time datetime="2017-07-24T00:00:00-05:00" itemprop="datePublished">Jul 24, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
      <noscript>
        <p><i>This article is best viewed with Javascript enabled, for math
          typesetting.</i></p>
      </noscript>
    
    <ul id="markdown-toc">
  <li><a href="#union-types" id="markdown-toc-union-types">Union types</a>    <ul>
      <li><a href="#in-typescript" id="markdown-toc-in-typescript">In TypeScript</a></li>
      <li><a href="#theory" id="markdown-toc-theory">Theory</a></li>
    </ul>
  </li>
  <li><a href="#sum-types" id="markdown-toc-sum-types">Sum types</a>    <ul>
      <li><a href="#in-ocaml" id="markdown-toc-in-ocaml">In OCaml</a></li>
      <li><a href="#theory-1" id="markdown-toc-theory-1">Theory</a></li>
    </ul>
  </li>
  <li><a href="#variant-types" id="markdown-toc-variant-types">Variant types</a></li>
  <li><a href="#differences" id="markdown-toc-differences">Differences</a>    <ul>
      <li><a href="#singleton-null-versus-a-null-for-every-type" id="markdown-toc-singleton-null-versus-a-null-for-every-type">Singleton null versus a null for every type</a></li>
      <li><a href="#distinguishing-identical-types-via-labels" id="markdown-toc-distinguishing-identical-types-via-labels">Distinguishing identical types via labels</a></li>
      <li><a href="#ad-hoc-polymorphism" id="markdown-toc-ad-hoc-polymorphism">Ad-hoc polymorphism</a></li>
      <li><a href="#mixing-labels-of-different-types" id="markdown-toc-mixing-labels-of-different-types">Mixing labels of different types</a></li>
      <li><a href="#adding-fields-to-an-existing-record-type" id="markdown-toc-adding-fields-to-an-existing-record-type">Adding fields to an existing record type</a></li>
    </ul>
  </li>
  <li><a href="#implementing-sum-types-in-terms-of-union-types" id="markdown-toc-implementing-sum-types-in-terms-of-union-types">Implementing sum types in terms of union types</a></li>
</ul>

<p>Functional programming features have been making their way into mainstream
languages lately, such as with new programming languages like Scala and Rust, or
new type systems for existing languages like TypeScript or Flow.</p>

<p>One popular feature is null-tracking: the compiler statically ensures that null
values are handled explicitly, instead of allowing failure at runtime with the
equivalent of a null-pointer exception. This can make it easier to reason about
the correctness of code.</p>

<p>Null-tracking is typically implemented in one of two ways:</p>

<ul>
  <li>with a <strong>union type</strong>, requiring <em>type refinement</em> to extract the non-null
value;</li>
  <li>or with a <strong>sum type</strong>, requiring <em>pattern matching</em> to extract the
non-null value.</li>
</ul>

<p>Union types and sum types are different beasts! But for some reason, there
doesn’t seem to be any treatment of the subject available with a quick Google
search.</p>

<p>In this article, I explain the difference between union and sum types and how
they differ in practice. I discuss both of these approaches for null-tracking,
but also cover how they differ for other purposes.</p>

<h2 id="union-types">Union types</h2>

<h3 id="in-typescript">In TypeScript</h3>

<p>TypeScript is a new statically-typed language by Microsoft that compiles down to
Javascript. It uses union types for null-tracking.</p>

<p>The syntax is mostly a superset of Javascript’s, but you can also annotate your
variables with types:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">greet</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">!</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can denote a union type using <code class="highlighter-rouge">|</code>. A type of <code class="highlighter-rouge">A | B</code> means “any value which
is either an A or a B (or both)”. We can express a nullable type by writing
<code class="highlighter-rouge">null | A</code> for any type <code class="highlighter-rouge">A</code>:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">filterString</span><span class="p">(</span><span class="nx">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">str</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">filtered</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then the following code is rejected by the typechecker because of the
possibility that <code class="highlighter-rouge">name</code> is null:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">readNameFromUser</span><span class="p">();</span>
<span class="nx">greet</span><span class="p">(</span><span class="nx">filterString</span><span class="p">(</span><span class="nx">name</span><span class="p">));</span>
<span class="c1">// error: `filterString` returns a `null | string`,</span>
<span class="c1">//        but `greet` takes a `string`.</span>
</code></pre></div></div>

<p>We could fix this by rewriting <code class="highlighter-rouge">greet</code> to take a nullable string and handle it
explicitly:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">greet</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The type of `name` has been refined to `null` in this branch.</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello, no-name!</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// The type of `name` has been refined to `string` in this branch.</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">!</span><span class="dl">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When seeing a special construct like <code class="highlighter-rouge">=== null</code> in an if-condition, the
typechecker knows to <em>refine</em> the type of <code class="highlighter-rouge">name</code> within the branch. Within that
branch, the type of <code class="highlighter-rouge">name</code> is known to be a more specific subset of its type
outside that branch.</p>

<h3 id="theory">Theory</h3>

<p>Let’s think of a type as a set of values. For example, the integer type could be
defined as the infinite set</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>int</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{int} = \left\{\cdots, -2, -1, 0, 1, 2, \cdots\right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord text"><span class="mord">int</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="minner">⋯</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mspace thinspace"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace thinspace"></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>

<p>A <em>union type</em> between two types <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> is simply the union of the two sets, denoted as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \cup
B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> So</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>bool</mtext><mo>∪</mo><mtext>int</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mtext>true</mtext><mo separator="true">,</mo><mtext>false</mtext><mo separator="true">,</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{bool} \cup \text{int} = \left\{\text{true}, \text{false}, \cdots, -2,
-1, 0, 1, 2, \cdots \right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord text"><span class="mord">bool</span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord">int</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord text"><span class="mord">true</span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">false</span></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mspace thinspace"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace thinspace"></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>

<p>The null type is the set containing one value, the null value. For clarity,
we’ll denote the null value as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="base"><span class="mord">∅</span></span></span></span>, and the null
type as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>null</mtext></mrow><annotation encoding="application/x-tex">\text{null}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord text"><span class="mord">null</span></span></span></span></span>:</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>null</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mi mathvariant="normal">∅</mi><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{null} = \left\{\emptyset\right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord text"><span class="mord">null</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">∅</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>

<p>So the type of <code class="highlighter-rouge">null | int</code> is</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>null</mtext><mo>∪</mo><mtext>int</mtext><mo>=</mo><mrow><mo fence="true">{</mo><mi mathvariant="normal">∅</mi><mo separator="true">,</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{null} \cup \text{int} = \left\{\emptyset, \cdots, -2, -1, 0, 1, 2,
\cdots\right\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord text"><span class="mord">null</span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord">int</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">∅</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mspace thinspace"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace thinspace"></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p>

<h2 id="sum-types">Sum types</h2>

<h3 id="in-ocaml">In OCaml</h3>

<p>OCaml is a mature functional programming language that uses the <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner
type system</a>. In OCaml, null-checking uses sum types.</p>

<p>ML-family languages represent the absence of a value using an <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data
type</a>. The following sum type is built into OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
  <span class="o">|</span> <span class="nc">None</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">option</code> type takes a generic type parameter <code class="highlighter-rouge">'a</code>, and can take on either
the value <code class="highlighter-rouge">Some</code> containing that value, or <code class="highlighter-rouge">None</code>, containing no value.</p>

<p>Note that although both union types and sum types are denoted with <code class="highlighter-rouge">|</code> in their
respective languages, these do not represent the same thing. This can be a
source of confusion for someone acquainted with languages in both families.</p>

<p>We can use this algebraic data type to force the programmer to check for null
when unpacking an <code class="highlighter-rouge">option</code>. For example:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">filter_string</span> <span class="p">(</span><span class="n">str</span> <span class="o">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">str</span> <span class="o">=</span> <span class="s2">"filtered"</span>
  <span class="k">then</span> <span class="nc">None</span>
  <span class="k">else</span> <span class="nc">Some</span> <span class="n">str</span>

<span class="k">let</span> <span class="n">greet</span> <span class="p">(</span><span class="n">name</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span><span class="p">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>
  <span class="c">(* It wouldn't compile to just write

     Printf.printf "Hello, %s!" name

     here, because `printf` is expecting a `string` but will have received a
     `string option`. *)</span>
  <span class="k">match</span> <span class="n">name</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Hello, no-name!"</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">name_</span> <span class="o">-&gt;</span>
    <span class="c">(* We've pattern-matched a `string` called `name_` out of the
       `string option` called `name`. Note that we could also call this
       variable `name` and shadow the outer `name`, but I don't here for
       clarity. *)</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Hello, %s!"</span> <span class="n">name_</span>
</code></pre></div></div>

<p>Instead of type refinement, where the compiler recognizes a special syntactic
pattern in order to do type inference, the language uses pattern-matching to
extract a value with the appropriate type out of an algebraic data type.</p>

<h3 id="theory-1">Theory</h3>

<p>A sum type is like a union type, but every type in the sum type is accompanied
by a <em>label</em>, which is a unique identifier for this element of the sum type.  If
we have types <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>, and
labels <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">l_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">l_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, then we
can define the sum type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> as</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi><mo>=</mo><mrow><mo fence="true">(</mo><mrow><mo fence="true">{</mo><msub><mi>l</mi><mi>A</mi></msub><mo fence="true">}</mo></mrow><mo>×</mo><mi>A</mi><mo fence="true">)</mo></mrow><mo>∪</mo><mrow><mo fence="true">(</mo><mrow><mo fence="true">{</mo><msub><mi>l</mi><mi>B</mi></msub><mo fence="true">}</mo></mrow><mo>×</mo><mi>B</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A + B = \left(\left\{l_A\right\} \times A\right)
  \cup \left(\left\{l_B\right\} \times B\right)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">A</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>

<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord">×</span></span></span></span> denotes <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>.</p>

<p>This overall operation is called <a href="https://en.wikipedia.org/wiki/Disjoint_union">disjoint union</a>. Basically, it can be
summarized as “a union, but each element remembers what set it came from”. Sum
types are also called “tagged unions” or “discriminated unions”.</p>

<p>As a concrete example, consider this data type:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">identifier</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Name</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="nc">IdNumber</span> <span class="k">of</span> <span class="kt">int</span>
</code></pre></div></div>

<p>This represents an identifier which is either a name or an ID number. Here are
the corresponding variables:</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>A</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mtext>string</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>B</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mtext>int</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>l</mi><mi>A</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mtext>&quot;name&quot;</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>l</mi><mi>B</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mtext>&quot;id number&quot;</mtext></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">
\begin{aligned}
A &amp;= \text{string} \\
B &amp;= \text{int} \\
l_A &amp;= \text{&quot;name&quot;} \\
l_B &amp;= \text{&quot;id number&quot;}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">A</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">string</span></span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">int</span></span></span></span><span style="top:-2.4099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">"name"</span></span></span></span><span style="top:-0.9099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">"id number"</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500000000000004em;"></span></span></span></span></span></span></span></span></span></span></p>

<p>Then the sum type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> using these labels is the
the set of all values depicted below:</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;name&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>&quot;&quot;</mtext><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;name&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>&quot;a&quot;</mtext><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;name&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>&quot;aa&quot;</mtext><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;name&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mtext>&quot;ab&quot;</mtext><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">⋮</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr></mtable><mspace width="1em"></mspace><mo>∪</mo><mspace width="1em"></mspace><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;id number&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0</mn><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;id number&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>1</mn><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;id number&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>2</mn><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>(</mo><mtext>&quot;id number&quot;</mtext><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>3</mn><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">⋮</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">
\begin{aligned}
(\text{&quot;name&quot;},&amp; &amp;\text{&quot;&quot;}) \\
(\text{&quot;name&quot;},&amp; &amp;\text{&quot;a&quot;}) \\
(\text{&quot;name&quot;},&amp; &amp;\text{&quot;aa&quot;}) \\
(\text{&quot;name&quot;},&amp; &amp;\text{&quot;ab&quot;}) \\
&amp; \vdots &amp;
\end{aligned}\quad\cup\quad\begin{aligned}
(\text{&quot;id number&quot;},&amp; &amp; 0) \\
(\text{&quot;id number&quot;},&amp; &amp; 1) \\
(\text{&quot;id number&quot;},&amp; &amp; 2) \\
(\text{&quot;id number&quot;},&amp; &amp; 3) \\
&amp; \vdots &amp;
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:4.030000000000001em;"></span><span class="strut bottom" style="height:7.560000000000002em;vertical-align:-3.5300000000000007em;"></span><span class="base"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"name"</span></span><span class="mpunct">,</span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"name"</span></span><span class="mpunct">,</span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"name"</span></span><span class="mpunct">,</span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"name"</span></span><span class="mpunct">,</span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">⋮</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">""</span></span><span class="mclose">)</span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">"a"</span></span><span class="mclose">)</span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">"aa"</span></span><span class="mclose">)</span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">"ab"</span></span><span class="mclose">)</span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mspace quad"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mspace quad"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"id number"</span></span><span class="mpunct">,</span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"id number"</span></span><span class="mpunct">,</span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"id number"</span></span><span class="mpunct">,</span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord text"><span class="mord">"id number"</span></span><span class="mpunct">,</span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">⋮</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.030000000000001em;"><span style="top:-6.190000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-4.69em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.1899999999999995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-1.6899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mclose">)</span></span></span><span style="top:-0.12999999999999945em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.5300000000000007em;"></span></span></span></span></span></span></span></span></span></span></p>

<p>In the <code class="highlighter-rouge">option</code> type, the labels are <code class="highlighter-rouge">Some</code> and <code class="highlighter-rouge">None</code>. Note that labels must be
unique across all sum types (or at least they must reside in different
namespaces). That is, this wouldn’t compile in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">foo</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Foo</span>

<span class="k">type</span> <span class="n">foo_or_bar</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Foo</span>
  <span class="o">|</span> <span class="nc">Bar</span>
</code></pre></div></div>

<h2 id="variant-types">Variant types</h2>

<p>Sometimes you may hear about “variant types”. Please don’t call either sum or
union types “variant types”. This terminology is confusing and can mean either
union or sum types, depending on the language and environment. For example, in
C++, <a href="http://en.cppreference.com/w/cpp/utility/variant"><code class="highlighter-rouge">std::variant</code></a> describes a union type, but in OCaml, “variant
types” are sum types.</p>

<h2 id="differences">Differences</h2>

<h3 id="singleton-null-versus-a-null-for-every-type">Singleton null versus a null for every type</h3>

<p>In the union type scheme, there is one null value that is shared across every
type. This can have some practical disadvantages. For example, let’s say that
you have a map that, when looking up a value, returns <code class="highlighter-rouge">null</code> if the key is not
found. Then there may be some ambiguity in a case like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">key</span><span class="p">:</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">getKey</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">map</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">getMap</span><span class="p">();</span>

<span class="c1">// Returns `null | null | int`, which is the same as `null | int`.</span>
<span class="kd">const</span> <span class="nx">value</span><span class="p">:</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">int</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Was this value not found, or was the value actually "null"?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This can be circumvented by having an additional null-like sentinel values, like
<code class="highlighter-rouge">undefined</code> in Javascript, but it can get confusing to remember the exact
semantics of them all, and still doesn’t let you store <code class="highlighter-rouge">undefined</code> in an
unambiguous way.</p>

<p>Sum types wrap their values in such a way that there is no ambiguity. For
example:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">key</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="n">get_key</span> <span class="bp">()</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">map</span> <span class="o">:</span> <span class="kt">string</span> <span class="p">(</span><span class="kt">int</span> <span class="n">option</span><span class="p">)</span> <span class="n">map</span> <span class="o">=</span> <span class="n">get_map</span> <span class="bp">()</span> <span class="k">in</span>

<span class="c">(* Note the double `option` -- the map wraps the result in another option. *)</span>
<span class="k">let</span> <span class="n">value</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="n">option</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">get</span> <span class="n">key</span> <span class="n">map</span> <span class="k">in</span>
<span class="k">match</span> <span class="n">value</span> <span class="k">with</span>
<span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Map did not contain key"</span>
<span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Map had value %d"</span> <span class="n">x</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Map had None"</span>
</code></pre></div></div>

<h3 id="distinguishing-identical-types-via-labels">Distinguishing identical types via labels</h3>

<p>With a union type between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>, if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> are the same,
there is no way to distinguish between elements from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span>
versus elements from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>.</p>

<p>For example, we can express this in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">file</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Filename</span> <span class="k">of</span> <span class="kt">string</span>
  <span class="o">|</span> <span class="nc">FileContents</span> <span class="k">of</span> <span class="kt">string</span>
</code></pre></div></div>

<p>This gives us some type-safety because then we can never mix the two up:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">print_file_contents</span> <span class="n">file</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">contents</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">file</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Filename</span> <span class="n">filename</span> <span class="o">-&gt;</span> <span class="n">read_file_from_disk</span> <span class="n">filename</span>
    <span class="o">|</span> <span class="nc">FileContents</span> <span class="n">file_contents</span> <span class="o">-&gt;</span> <span class="n">file_contents</span>
  <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"File contents: %s"</span> <span class="n">contents</span>
</code></pre></div></div>

<p>However, sum types can be implemented in terms of union types, as described
later.</p>

<h3 id="ad-hoc-polymorphism">Ad-hoc polymorphism</h3>

<p>Union types can be used to implement a form of function overloading:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printAnything</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">int</span> <span class="o">|</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">bool</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">int</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">The int was </span><span class="dl">"</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">The string was </span><span class="dl">"</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">The bool was </span><span class="dl">"</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>OCaml does not support <a href="https://en.wikipedia.org/wiki/Ad-hoc_polymorphism">ad-hoc polymorphism</a> like this. Indeed, one of the warts
of the language that it needs two different operators <code class="highlighter-rouge">+</code> and <code class="highlighter-rouge">+.</code> for addition
between integers and floats, respectively.</p>

<h3 id="mixing-labels-of-different-types">Mixing labels of different types</h3>

<p>In a sum type, the labels of different sum types are not interchangeable. You
cannot write this in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">foo</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Foo</span> <span class="k">of</span> <span class="kt">string</span>

<span class="k">type</span> <span class="n">bar</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Bar</span> <span class="k">of</span> <span class="kt">int</span>

<span class="k">let</span> <span class="n">takes_a_foo_or_bar</span> <span class="n">foo_or_bar</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">foo_or_bar</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Foo</span> <span class="n">foo</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Got string %s"</span> <span class="n">foo</span>
  <span class="o">|</span> <span class="nc">Bar</span> <span class="n">bar</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Got int %d"</span> <span class="n">bar</span>
</code></pre></div></div>

<p>This can be worked around with so-called <a href="https://realworldocaml.org/v1/en/html/variants.html#polymorphic-variants">polymorphic variants</a> in OCaml, but
they are not a general staple of ML-family languages. (SML doesn’t have them.)</p>

<h3 id="adding-fields-to-an-existing-record-type">Adding fields to an existing record type</h3>

<p>Union types are usually accompanied by intersection types. We can use an
intersection type to add fields to an existing record type:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="nx">string</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="nx">number</span> <span class="p">}</span>

<span class="c1">// Same as the `User` type, but every record also has an `email` field.</span>
<span class="nx">type</span> <span class="nx">UserWithEmail</span> <span class="o">=</span> <span class="nx">User</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">email</span><span class="p">:</span> <span class="nx">string</span> <span class="p">}</span>
</code></pre></div></div>

<p>This is especially useful for processing data in stages and attaching additional
fields to records as we determine their values. For example, in a compiler, we
might start with a container of all the variables in the programs, and then
attach the type to each variable as we determine it.</p>

<p>With sum types (even polymorphic variants, as in OCaml), we can’t add new fields
to existing record types. We can only create new sum types with the added
fields, and convert between the two. This is more difficult to work with in some
situations, since one has to implement boilerplate code to convert from one to
the other.</p>

<h2 id="implementing-sum-types-in-terms-of-union-types">Implementing sum types in terms of union types</h2>

<p>The definition of sum type involves a union. So if we can add a label to our
union types, we can emulate a sum type. The general technique is as follows:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Filename</span> <span class="p">{</span>
  <span class="nl">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">filename</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">filename</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">FileContents</span> <span class="p">{</span>
  <span class="nl">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">file_contents</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">contents</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">File</span> <span class="o">=</span> <span class="nx">Filename</span> <span class="o">|</span> <span class="nx">FileContents</span>

<span class="kd">function</span> <span class="nx">printFileContents</span><span class="p">(</span><span class="nx">file</span><span class="p">:</span> <span class="nx">File</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">label</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">filename</span><span class="dl">"</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">File contents: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">readFileFromDisk</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">filename</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">file_contents</span><span class="dl">"</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">File contents: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">contents</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="c1">// We need this to enforce an exhaustiveness check by the compiler, so</span>
      <span class="c1">// that we don't forget a case.</span>
      <span class="kd">const</span> <span class="na">_exhaustiveCheck</span><span class="p">:</span> <span class="nx">never</span> <span class="o">=</span> <span class="nx">file</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On the other hand, we can’t implement union types in terms of sum types.
Therefore union types are strictly more flexible than sum types, but the
ergonomics of each approach depends on the use-case.</p>

  </div>

</article>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">



<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://waleedkhan.name/blog/union-vs-sum-types/";
    this.page.identifier = "union-vs-sum-types/";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//waleedkhan-name.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Stenography and programming languages</h2>
    <p class="rss-subscribe">subscribe <a href="/blog/feed.xml">via RSS</a></p>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Waleed Khan</li>
          <li><a href="mailto:me@waleedkhan.name">me@waleedkhan.name</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/arxanas"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>This is a personal blog. Unless otherwise stated, the opinions
expressed here are my own, and not those of my past or present
employers.</p>
      </div>
    </div>

  </div>

  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53066274-1', 'auto');
ga('send', 'pageview');
</script>



</footer>


  </body>

</html>
