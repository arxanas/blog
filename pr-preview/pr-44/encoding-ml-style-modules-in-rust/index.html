<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
    <title>Encoding ML-style modules in Rust</title>
  
  <meta name="author" content="Waleed Khan">
  <meta name="description" content="            Intended audience              OCaml/SML programmers learning Rust.        New-wave functional programmers who haven‚Äôt used older languages like ...">

  <link rel="stylesheet" href="/pr-preview/pr-44/css/main.css">
  <link rel="canonical" href="https://blog.waleedkhan.name/pr-preview/pr-44/encoding-ml-style-modules-in-rust/">
  <link rel="alternate" type="application/rss+xml" title="Steno & PL" href="https://blog.waleedkhan.name/pr-preview/pr-44/feed.xml">
  <script src="//instant.page/5.1.0" type="module" integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
  

  <link rel="me" href="https://github.com/arxanas">
  <link rel="me" href="https://twitter.com/arxanas">
  <link rel="me" href="mailto:me@waleedkhan.name">

  
  

  <!-- See https://indieweb.org/webmention.io -->
  <link rel="webmention" href="https://webmention.io/blog.waleedkhan.name/webmention" />
  <link rel="pingback" href="https://webmention.io/webmention?forward=https://blog.waleedkhan.name/webmention" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/pr-preview/pr-44/">Steno & PL</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          <a class="page-link" href="/pr-preview/pr-44/about/">About</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Encoding ML-style modules in Rust</h1>
    <p class="post-meta"><time datetime="2023-06-17T00:00:00+00:00" itemprop="datePublished">Jun 17, 2023</time>
    
      <span class="post-meta">
        <br />
        
        <a href="/pr-preview/pr-44/pl/kodowanie-w-rust-modu≈Ç√≥w-w-stylu-ml/">Czytaj po polsku üáµüá±</a>
        
      </span>
    
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
    <div class="publication-notes">
  <table>
    <tr>
      <td>Intended audience</td>
      <td><ul>
        <li>OCaml/SML programmers learning Rust.</li>
        <li>New-wave functional programmers who haven‚Äôt used older languages like OCaml or Haskell, but who might be interested in a certain abstraction technique.</li>
        <ul><li>
        Note that ‚ÄúML-style module‚Äù refers to <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">the ML family of programming languages</a>, not <a href="https://en.wikipedia.org/wiki/Machine_learning">machine learning</a>.
        </li></ul>
      </ul>
      </td>
    </tr>
    <tr>
      <td>Origin</td>
      <td><ul>
        <li>OCaml and Rust experience.</li>
        <li>Type theory experience.</li>
      </ul></td>
    </tr>
    <tr>
      <td>Mood</td>
      <td>Helpful.</td>
    </tr>
  </table>
</div>

<div class="series-and-toc">

  <p class="toc-header">Table of contents:</p>

<ul id="markdown-toc">
  <li><a href="#problem-statement" id="markdown-toc-problem-statement">Problem statement</a></li>
  <li><a href="#caching-a-function" id="markdown-toc-caching-a-function">Caching a function</a>    <ul>
      <li><a href="#caching-an-individual-function" id="markdown-toc-caching-an-individual-function">Caching an individual function</a></li>
      <li><a href="#caching-functions-generically" id="markdown-toc-caching-functions-generically">Caching functions generically</a></li>
      <li><a href="#treating-the-function-as-a-value" id="markdown-toc-treating-the-function-as-a-value">Treating the function as a value</a></li>
    </ul>
  </li>
  <li><a href="#encoding-modules" id="markdown-toc-encoding-modules">Encoding modules</a>    <ul>
      <li><a href="#modules-in-ocaml" id="markdown-toc-modules-in-ocaml">Modules in OCaml</a></li>
      <li><a href="#associated-types" id="markdown-toc-associated-types">Associated types</a></li>
      <li><a href="#parametrizing-over-types-only" id="markdown-toc-parametrizing-over-types-only">Parametrizing over types only</a></li>
      <li><a href="#other-encodings" id="markdown-toc-other-encodings">Other encodings</a></li>
    </ul>
  </li>
  <li><a href="#related-posts" id="markdown-toc-related-posts">Related posts</a></li>
  <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
</ul>

</div>

<h2 id="problem-statement">Problem statement</h2>

<p>Problem: you want to take an existing type satisfying some trait and augment it with new functionality ‚Äî including new internal state.</p>

<p>If you <em>didn‚Äôt</em> want to add any internal state, there are many solutions:</p>

<ul>
  <li>You could use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#default-implementations">default implementations for trait methods</a>.</li>
  <li>You could use <a href="https://rust-lang.github.io/rfcs/0445-extension-trait-conventions.html">extension traits</a>.</li>
  <li>You could use <a href="https://radicle.community/t/rust-s-impl-dyn-trait-syntax/102"><code class="language-plaintext highlighter-rouge">impl dyn</code></a> (<span class="note-inline"><span class="note-tag note-info">technical note:</span> uses dynamic dispatch at runtime</span>).</li>
  <li>You could use free (global) functions which are generic and accept any type implementing the trait.</li>
</ul>

<p>One example of this problem would be implementing a caching layer <em>once</em> that could then be applied to <em>any</em> implementation of some <code class="language-plaintext highlighter-rouge">Backend</code> trait.</p>

<p>ML-style modules are a natural fit for this kind of problem. They‚Äôre more capable than traditional ‚Äúmodules‚Äù, as considered in mainstream programming languages. Both ML-style and traditional of modules support:</p>

<ul>
  <li>Separating code into logical namespaces.</li>
  <li>Defining interfaces.</li>
  <li>Abstracting data types and hiding implementation details.</li>
</ul>

<p>But ML-style modules can be parametrized on <em>types</em> (similar to templates or generics in mainstream languages) or even <em>other modules</em> (discussed in this article).</p>

<p>Although Rust descends from OCaml, it doesn‚Äôt inherit an ML-style module system. Instead, Rust‚Äôs trait system resembles <a href="https://en.wikipedia.org/wiki/Type_class">Haskell‚Äôs typeclasses</a>. However, with some additional features (associated types), we can simulate ML-style modules in Rust.</p>

<div class="note-block note-info">
          <p><span class="note-tag note-info">Pedagogically:</span> The canonical example for ML-style modules over typeclasses is perhaps creating a new kind of tree-set which accepts different orderings, ratther than being restricted to a single ordering per type. I think that example is rather boring to consider because it doesn‚Äôt solve Real Engineering Problems, and because the typeclass solution ‚Äî¬†creating a wrapper type with the new ordering ‚Äî is roughly the same amount of work for the programmer.</p>

        </div>

<h2 id="caching-a-function">Caching a function</h2>

<p>Suppose we have an expensive computation we want to cache (perhaps it queries a database or does lots of CPU-bound work). For the sake of example, we‚Äôll use a function that calculates the length of a string:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Called expensive function str_len"</span><span class="p">);</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="caching-an-individual-function">Caching an individual function</h3>

<p>How do we write a function that acts like <code class="language-plaintext highlighter-rouge">str_len</code>, but caches the results such that we never compute the same key-value pair twice? One way is to generate a wrapper function with a mutable internal cache and calls the underlying <code class="language-plaintext highlighter-rouge">str_len</code> function when the value isn‚Äôt in the cache:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Declare that we return an `FnMut` rather than an `Fn`</span>
<span class="c1">// because the returned closure may modify mutable state</span>
<span class="c1">// (and thus isn't safe to call in parallel -- not relevant</span>
<span class="c1">// in this example).</span>
<span class="k">fn</span> <span class="nf">make_cached_str_len</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="c1">// Use the `move` keyword to move the mutable `cache`</span>
    <span class="c1">// into the returned closure object. Unlike a variable defined</span>
    <span class="c1">// in the closure body itself, this cache will be shared across</span>
    <span class="c1">// *all* invocations of the new function.</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// For simplicity, we clone the `&amp;str` as the cache key</span>
        <span class="c1">// rather than worry about the lifetime annotations here.</span>
        <span class="c1">// If we didn't do this, it's possible that our internal `cache`</span>
        <span class="c1">// would hold a reference to a `str` even after that `str` was freed.</span>
        <span class="k">let</span> <span class="n">key</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="c1">// Look up the entry in our cache,</span>
        <span class="c1">// or create a new one if none exists.</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="o">*</span><span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">make_cached_str_len</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Of course, it‚Äôs also possible to create a <code class="language-plaintext highlighter-rouge">struct</code> which holds the internal <code class="language-plaintext highlighter-rouge">cache</code>, and to simply demand that the caller invoke the wrapped function via a <code class="language-plaintext highlighter-rouge">.call</code> method.</p>

<div class="note-block note-info">
          <p><span class="note-tag note-info">Technical note:</span> Rust does not currently support overloading the function call operator.</p>

        </div>

<h3 id="caching-functions-generically">Caching functions generically</h3>

<p>Now to abstract this by one level: what if we want to write a generic caching function that can cache the results of <em>any</em> function, not just <code class="language-plaintext highlighter-rouge">str_len</code> specifically?</p>

<div class="note-block note-info">
          <p><span class="note-tag note-info">Technical note:</span> To simplify the situation, we‚Äôll restrict ourselves to caching the results of only functions which accept exactly one parameter, as <a href="https://github.com/rust-lang/rfcs/issues/376">Rust currently does not support variadic generics</a>.</p>

        </div>

<p>We can accomplish this with a generic function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create a function which is generic over the key and value types,</span>
<span class="c1">// and accepts a "base" function which takes a key and returns a value.</span>
<span class="c1">//</span>
<span class="c1">// In order to store the key in the cache, we had to add the additional</span>
<span class="c1">// bounds `Eq + Hash` to `K`. To simplify the lifetimes, we added</span>
<span class="c1">// the lifetime bound `'static` to `K` and the bound `Clone` to `V`</span>
<span class="c1">// (and cloned the value before returning it).</span>
<span class="k">fn</span> <span class="n">cache_f</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="p">(</span><span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">move</span> <span class="p">|</span><span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="n">V</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">V</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nf">f</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
        <span class="n">result</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we adjust the parameter we pass slightly for the types to work in this example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// To make some types work, add an additional `&amp;`</span>
    <span class="c1">// to the parameter type.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Called expensive function str_len</span>
    <span class="c1">// Cached str len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached str len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="treating-the-function-as-a-value">Treating the function as a value</h3>

<p>Of course, since we went to all the trouble of making this cache, we probably want to pass it around and use it. Ideally, we would be able to write it like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `impl T` does not compile (yet).</span>
<span class="k">type</span> <span class="n">CachedF</span><span class="o">&lt;</span><span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">V</span><span class="p">;</span>
<span class="k">type</span> <span class="n">CachedStrLenF</span> <span class="o">=</span> <span class="n">CachedF</span><span class="o">&lt;&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But it unfortunately produces this error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0658]: `impl Trait` in type aliases is unstable
  --&gt; src/bin/main3-pass-function.rs:24:50
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |                                                  ^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #63063 &lt;https://github.com/rust-lang/rust/issues/63063&gt; for more information

error: non-defining opaque type use in defining scope
  --&gt; src/bin/main3-pass-function.rs:35:5
   |
35 |     accepts_cached_str_len(cached_str_len);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: used non-generic type `&amp;'static str` for generic parameter
  --&gt; src/bin/main3-pass-function.rs:24:14
   |
24 | type CachedF&lt;K: Eq + Hash + 'static, V: Clone&gt; = impl FnMut(K) -&gt; V;
   |              ^
</code></pre></div></div>

<p>We can‚Äôt use <code class="language-plaintext highlighter-rouge">impl Fn</code> in a type alias, so we have to actually write it out:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 1/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached str len 2/2: {}"</span><span class="p">,</span> <span class="nf">cached_str_len</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nf">cache_f</span><span class="p">(|</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">|</span> <span class="nf">str_len</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That is, <em>every use of our function type has to also include the generic type parameters.</em> This ‚Äúinfectious‚Äù behavior quickly becomes unwieldy in practice for programs of even moderate size.</p>

<h2 id="encoding-modules">Encoding modules</h2>

<h3 id="modules-in-ocaml">Modules in OCaml</h3>

<p>ML-style modules can ‚Äúhide‚Äù the generic types in a way that generic functions alone can‚Äôt accomplish (<span class="note-inline"><span class="note-tag note-info">technical note:</span> using a form of <a href="https://en.wikipedia.org/wiki/Type_system#Existential_types">existential types</a></span>). To express a similar example using ML-style modules, you can skim over ‚Äî¬†and probably not understand ‚Äî the following OCaml code:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Backend</span> <span class="o">=</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span>
    <span class="k">val</span> <span class="n">compute</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">StrLenBackend</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">unit</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="kt">string</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="kt">int</span>
  <span class="k">let</span> <span class="n">make</span> <span class="bp">()</span> <span class="o">=</span> <span class="bp">()</span>
    <span class="k">let</span> <span class="n">compute</span> <span class="bp">()</span> <span class="n">key</span> <span class="o">=</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Computing length of string %s</span><span class="se">\n</span><span class="s2">"</span> <span class="n">key</span><span class="p">;</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">key</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">CachedBackend</span><span class="p">(</span><span class="nc">B</span><span class="o">:</span> <span class="nc">Backend</span><span class="p">)</span> <span class="o">:</span> <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
    <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
  <span class="k">val</span> <span class="n">make</span> <span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compute_cached</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span>
<span class="k">end</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">key</span>
  <span class="k">type</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">value</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">backend</span><span class="o">:</span> <span class="nn">B</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
        <span class="n">cache</span><span class="o">:</span> <span class="p">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="p">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">let</span> <span class="n">make</span> <span class="n">backend</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">;</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="k">let</span> <span class="n">compute_cached</span> <span class="n">t</span> <span class="n">key</span> <span class="o">=</span> <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nn">B</span><span class="p">.</span><span class="n">compute</span> <span class="n">t</span><span class="o">.</span><span class="n">backend</span> <span class="n">key</span> <span class="k">in</span>
      <span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="n">key</span> <span class="n">value</span> <span class="k">in</span>
      <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The point is ultimately that you can write a function like <code class="language-plaintext highlighter-rouge">accepts_cached_str_len</code> using a non-generic type like <code class="language-plaintext highlighter-rouge">CachedStrLenBackend.t</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">accepts_cached_str_len</span> <span class="p">(</span><span class="n">cached_str_len</span> <span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="k">in</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 1/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Cached len 2/2: %d</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">compute_cached</span> <span class="n">cached_str_len</span> <span class="n">key</span><span class="p">);</span>
  <span class="bp">()</span>
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="nn">StrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cached_str_len</span><span class="o">:</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">.</span><span class="n">make</span> <span class="n">backend</span> <span class="k">in</span>
  <span class="n">accepts_cached_str_len</span> <span class="n">cached_str_len</span><span class="p">;</span>
 <span class="bp">()</span>
</code></pre></div></div>

<h3 id="associated-types">Associated types</h3>

<p>To accomplish something similar to ML-style modules, we can use <a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Rust‚Äôs associated types</a>. The first thing we‚Äôll do is convert our function types into traits (<span class="note-inline"><span class="note-tag note-info">technical note:</span> ultimately, a form of <a href="https://en.wikipedia.org/wiki/Defunctionalization">defunctionalization</a></span>).</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="c1">// We declare "associated types" for this trait. For any type </span>
    <span class="c1">// which implements `Backend`, it must declare corresponding `Key`</span>
    <span class="c1">// and `Value` types, and include an implementation of `compute`</span>
    <span class="c1">// adhering to those types.</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now we‚Äôll create our <code class="language-plaintext highlighter-rouge">str_len</code> function as a new type and an implementation of the <code class="language-plaintext highlighter-rouge">Backend</code> trait:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This type doesn't need state, but you could imagine</span>
<span class="c1">// embedding e.g. a database connection in this struct.</span>
<span class="c1">//</span>
<span class="c1">// Normally, types without any data aren't very useful, but</span>
<span class="c1">// this is one of the key ideas of the "encoding of ML-style</span>
<span class="c1">// modules". Instead of state (or in addition to state), the</span>
<span class="c1">// type instead has associated types and functions,</span>
<span class="c1">// declared below.</span>
<span class="c1">//</span>
<span class="c1">// This type corresponds to the "closed-over" variables</span>
<span class="c1">// of a closure object.</span>
<span class="k">struct</span> <span class="n">StrLenBackend</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, how do we define a generic version of a ‚Äúcached‚Äù backend which works for <em>any</em> kind of <code class="language-plaintext highlighter-rouge">Backend</code>? A simple generic function like <code class="language-plaintext highlighter-rouge">compute_cached&lt;B: Backend&gt;</code> doesn‚Äôt work, since we want it to store state. Instead, we declare <em>another</em> type which is parametrized on a <code class="language-plaintext highlighter-rouge">Backend</code> type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="c1">// We require that the wrapped backend adheres to these bounds</span>
    <span class="c1">// in order to call any of the functions in this `impl`</span>
    <span class="c1">// (including `new`, which is how you would get a new value</span>
    <span class="c1">// of this type).</span>
    <span class="c1">//</span>
    <span class="c1">// Previously, we had to add the appropriate bounds to </span>
    <span class="c1">// each generic type in each place that it appeared.</span>
    <span class="c1">// Using a `trait`, we can instead declare the bounds</span>
    <span class="c1">// just once on the `impl`.</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">:</span> <span class="n">B</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">backend</span><span class="p">,</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="k">self</span><span class="py">.backend</span><span class="nf">.compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we construct values of the types and pass them around. Unlike before, we can even create a type alias for the cached function type ‚Äî¬†without having to re-specify generic type parameters everywhere.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">backend</span> <span class="o">=</span> <span class="n">StrLenBackend</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">backend</span><span class="p">);</span>
    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="parametrizing-over-types-only">Parametrizing over types only</h3>

<p>Passing around values that embody modules is actually the most powerful form of this technique, corresponding to <em>first-class modules</em>, but this is probably the most natural form to express in Rust, because most programmers deal with values rather than types. Ideally, we would hope that the optimizer would remove the overhead of passing around a value which has no associated data.</p>

<p>One rarely needs to do this, but it‚Äôs possible to dispatch on the type only, and forbid even constructing a value. This is also pedagogically interesting as an example of type-directed code generation in Rust. To rewrite the above example without instantiating the <code class="language-plaintext highlighter-rouge">Backend</code>, we remove the <code class="language-plaintext highlighter-rouge">&amp;self</code> parameter everywhere:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Backend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span><span class="p">;</span>

    <span class="c1">// We no longer take a value of type `&amp;self`.</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// In Rust, it's not possible to make a value of the type</span>
<span class="c1">// of an empty enum.</span>
<span class="k">enum</span> <span class="n">StrLenBackend</span> <span class="p">{}</span>

<span class="k">impl</span> <span class="n">Backend</span> <span class="k">for</span> <span class="n">StrLenBackend</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span><span class="p">;</span>
    <span class="k">type</span> <span class="n">Value</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Computing length of key {key:?}"</span><span class="p">);</span>
        <span class="n">key</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then adjust our <code class="language-plaintext highlighter-rouge">CachedBackend</code> to use <code class="language-plaintext highlighter-rouge">B</code> directly, instead of calling methods on a value of type <code class="language-plaintext highlighter-rouge">B</code>, such as calling <code class="language-plaintext highlighter-rouge">B::compute</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Note that we no longer have a member of type `B`.</span>
<span class="k">struct</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">,</span> <span class="nn">B</span><span class="p">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">B</span><span class="p">:</span> <span class="n">Backend</span><span class="o">&gt;</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">cache</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">compute_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nn">B</span><span class="p">::</span><span class="n">Key</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nn">B</span><span class="p">::</span><span class="n">Value</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cache</span>
            <span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="nf">.or_insert_with_key</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="nn">B</span><span class="p">::</span><span class="nf">compute</span><span class="p">(</span><span class="n">key</span><span class="nf">.clone</span><span class="p">()))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">CachedStrLenBackend</span> <span class="o">=</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="k">mut</span> <span class="n">cached_str_len</span><span class="p">:</span> <span class="n">CachedStrLenBackend</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>

    <span class="c1">// Prints:</span>
    <span class="c1">// Computing length of key "foo"</span>
    <span class="c1">// Cached len 1/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 1/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

    <span class="c1">// Cached len 2/2: 3</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Cached len 2/2: {}"</span><span class="p">,</span> <span class="n">cached_str_len</span><span class="nf">.compute_cached</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// This weird syntax is equivalent to `CachedBackend&lt;StrLenBackend&gt;::new()`</span>
    <span class="c1">// in some other languages. It's written with an extra `::` due to</span>
    <span class="c1">// technical restrictions on the syntax.</span>
    <span class="c1">//</span>
    <span class="c1">// Note that, unlike before, we never pass a *value* into</span>
    <span class="c1">// the `CachedBackend`, only a type.</span>
    <span class="k">let</span> <span class="n">cached_str_len</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// We could also write the type annotation on the left side and let</span>
    <span class="c1">// type inference figure it out:</span>
    <span class="k">let</span> <span class="n">_also_works</span><span class="p">:</span> <span class="n">CachedBackend</span><span class="o">&lt;</span><span class="n">StrLenBackend</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">CachedBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Or we could use our previously-defined type alias:</span>
    <span class="k">let</span> <span class="n">_also_works</span> <span class="o">=</span> <span class="nn">CachedStrLenBackend</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="nf">accepts_cached_str_len</span><span class="p">(</span><span class="n">cached_str_len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="other-encodings">Other encodings</h3>

<p>ML-style modules include other features than the above. Here‚Äôs a brief discussion of encoding those features:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">include</code>:
    <ul>
      <li>You can use the previously-mentioned approaches, such as extension traits.</li>
      <li>Or you can use macros ‚Äî¬†I have seen this done in production systems. (There are well-documented problems with macros that I will not discuss here.)</li>
    </ul>
  </li>
  <li>Updating modules, i.e. creating a new definition of an existing module with one associated type redefined.
    <ul>
      <li>Other than macros, I haven‚Äôt seen an encoding for this.</li>
    </ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Structural_type_system">Structural typing</a>:
    <ul>
      <li>Rust simply does not like allowing module-like objects to be structurally typed. You can try to convert your implicit structural types into an explicit trait hierarchy.</li>
      <li>Or you can use macros.</li>
    </ul>
  </li>
  <li>Applicative vs generative functors
    <ul>
      <li>See <a href="https://stackoverflow.com/q/52161048/344643">https://stackoverflow.com/questions/52161048/applicative-vs-generative-functors</a></li>
      <li>It depends on the concrete encoding of the module. Type abstractions are manually introduced with associated types and always unequal, while types passed via generic type parameter can be considered equal. So if you want a generative functor, you can directly introduce a new abstract type via another layer of <code class="language-plaintext highlighter-rouge">trait</code> with an associated type.</li>
    </ul>
  </li>
</ul>

<p>See also <a href="http://blog.ezyang.com/2013/05/the-ast-typing-problem/">The AST typing problem</a> for related questions on the practical encoding of modules.</p>

<h2 id="related-posts">Related posts</h2>

<p>The following are hand-curated posts which you might find interesting.</p>

<table class="related-posts">
<thead>
  <tr>
    <th>Date</th>
    <th></th>
    <th>Title</th>
  </tr>
</thead>

<tbody>


  <tr>
    <td>03&nbsp;Jan&nbsp;2021</td>
    <td class="this-post">
      
      </td>
    <td><a href="/rust-modules-for-python-users/">The Rust module system for Python users</a>
    </td>
  </tr>

  <tr>
    <td>29&nbsp;Apr&nbsp;2021</td>
    <td class="this-post">
      
      </td>
    <td><a href="/port-python-to-rust/">Incrementally porting a small Python project to Rust</a>
    </td>
  </tr>

  <tr>
    <td>24&nbsp;Jan&nbsp;2023</td>
    <td class="this-post">
      
      </td>
    <td><a href="/tracing-rust-cli-apps/">Using `tracing` with Rust CLI applications</a>
    </td>
  </tr>

  <tr>
    <td>07&nbsp;Feb&nbsp;2023</td>
    <td class="this-post">
      
      </td>
    <td><a href="/rust-incremental-test-times/">Improving incremental test times in Rust</a>
    </td>
  </tr>

  <tr>
    <td>17&nbsp;Jun&nbsp;2023</td>
    <td class="this-post">
      
      (this&nbsp;post)
      
      </td>
    <td><a href="/encoding-ml-style-modules-in-rust/">Encoding ML-style modules in Rust</a>
    </td>
  </tr>

</tbody>
</table>

<p>Want to see more of my posts? Follow me <a href="https://twitter.com/arxanas">on Twitter</a> or subscribe <a href="/pr-preview/pr-44/feed.xml">via RSS</a>.</p>

<h2 id="comments">Comments</h2>

<ul>


<li><a class="icon-lobsters" href="https://lobste.rs/s/hcwjcs/encoding_ml_style_modules_rust ">Discussion on Lobsters</a></li>


</ul>

<script type="text/javascript" src="/pr-preview/pr-44/scripts/github-comment-links.js"></script>

<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://blog.waleedkhan.name/pr-preview/pr-44/encoding-ml-style-modules-in-rust/";
    this.page.identifier = "encoding-ml-style-modules-in-rust/";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//waleedkhan-name.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Steno & PL</h2>
    
    <p class="rss-subscribe">subscribe <a href="/pr-preview/pr-44/feed.xml">via RSS</a></p>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Waleed Khan</li>
          <li><a href="mailto:me@waleedkhan.name">me@waleedkhan.name</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/arxanas"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/arxanas"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>This is a personal blog. Unless otherwise stated, the opinions expressed here are my own, and not those of my past or present employers.</p>
      </div>
    </div>

  </div>

  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53066274-1', 'auto');
ga('send', 'pageview');
</script>



</footer>


  </body>

</html>
