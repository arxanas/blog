<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
    <title>Incrementally porting a small Python project to Rust</title>
  
  <meta name="description" content="I’ve been working on git-branchless, a Git workflow similar to the Mercurial “stacked-diff” workflows used at Google and Facebook. I originally wrote it in P...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.waleedkhan.name/port-python-to-rust/">
  <link rel="alternate" type="application/rss+xml" title="Steno & PL" href="https://blog.waleedkhan.name/feed.xml">
  <script src="//instant.page/5.1.0" type="module" integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Steno & PL</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          <a class="page-link" href="/about/">About</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Incrementally porting a small Python project to Rust</h1>
    <p class="post-meta"><time datetime="2021-04-29T00:00:00-05:00" itemprop="datePublished">Apr 29, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    
    <p>I’ve been working on <a href="https://github.com/arxanas/git-branchless">git-branchless</a>, a Git workflow similar to the Mercurial “stacked-diff” workflows used at Google and Facebook. I originally wrote it in Python, but later ported it to Rust. This post details various aspects of the porting process.</p>

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ul>
      <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
      <li><a href="#why-rust" id="markdown-toc-why-rust">Why Rust?</a></li>
      <li><a href="#previous-rust-experience" id="markdown-toc-previous-rust-experience">Previous Rust experience</a></li>
      <li><a href="#why-incremental" id="markdown-toc-why-incremental">Why incremental?</a></li>
    </ul>
  </li>
  <li><a href="#porting" id="markdown-toc-porting">Porting</a>    <ul>
      <li><a href="#strategy" id="markdown-toc-strategy">Strategy</a></li>
      <li><a href="#ide-ergonomics" id="markdown-toc-ide-ergonomics">IDE ergonomics</a></li>
      <li><a href="#build-ergonomics" id="markdown-toc-build-ergonomics">Build ergonomics</a></li>
      <li><a href="#testing-ergonomics" id="markdown-toc-testing-ergonomics">Testing ergonomics</a></li>
      <li><a href="#interop-ergonomics" id="markdown-toc-interop-ergonomics">Interop ergonomics</a>        <ul>
          <li><a href="#pyo3s-hello-world" id="markdown-toc-pyo3s-hello-world">PyO3’s hello world</a></li>
          <li><a href="#real-example" id="markdown-toc-real-example">Real example</a></li>
        </ul>
      </li>
      <li><a href="#bugs-encountered" id="markdown-toc-bugs-encountered">Bugs encountered</a></li>
    </ul>
  </li>
  <li><a href="#results" id="markdown-toc-results">Results</a>    <ul>
      <li><a href="#porting-time" id="markdown-toc-porting-time">Porting time</a></li>
      <li><a href="#lines-of-code" id="markdown-toc-lines-of-code">Lines of code</a></li>
      <li><a href="#time-comparison" id="markdown-toc-time-comparison">Time comparison</a></li>
    </ul>
  </li>
  <li><a href="#conclusions" id="markdown-toc-conclusions">Conclusions</a></li>
  <li><a href="#related-posts" id="markdown-toc-related-posts">Related posts</a></li>
  <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<h3 id="motivation">Motivation</h3>

<p>Initially, I prototyped a working version of git-branchless using Python. The <code class="language-plaintext highlighter-rouge">git-branchless</code> executable can be invoked in one of two ways:</p>

<ol>
  <li><strong>Explicitly by a user’s command</strong>. For example, <code class="language-plaintext highlighter-rouge">git-branchless smartlog</code>. This is typically aliased to <code class="language-plaintext highlighter-rouge">git sl</code>.</li>
  <li><strong>By a <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git “hook”</a></strong>. This is an event that triggers when specific actions occur in the repository. For example, when a user makes a commit, it triggers the <code class="language-plaintext highlighter-rouge">post-commit</code> hook, which then tells <code class="language-plaintext highlighter-rouge">git-branchless</code> to register the commit in its internal database.</li>
</ol>

<p>However, some Git operations can result in many Git hook invocations, and therefore Python invocations. For example, a rebase of a stack of several commits will trigger several <code class="language-plaintext highlighter-rouge">post-commit</code> hooks in sequence. The Python interpreter takes tens or hundreds of milliseconds to start up, which degrades performance in the situation where we invoke it many times serially.</p>

<p>I considered incorporating a long-running background process into the architecture, but I hate the amount of additional complexity and edge-cases associated with such an approach. Instead, I decided to rewrite the project in Rust to address the startup time issue.</p>

<h3 id="why-rust">Why Rust?</h3>

<p>These were the requirements for my choice of language:</p>

<ul>
  <li>Fast startup time.</li>
  <li>Bindings to <a href="https://www.sqlite.org/index.html">SQLite</a>, <a href="https://libgit2.org/"><code class="language-plaintext highlighter-rouge">libgit2</code></a> (or equivalent).</li>
  <li>Bindings to some kind of <a href="https://en.wikipedia.org/wiki/Text-based_user_interface">TUI</a> library.</li>
  <li>Python interop, to support an incremental porting approach.</li>
</ul>

<p>I chose Rust because I had some prior experience with it, and I liked the ML-style type system. The Python codebase was already statically-checked with Mypy and written in an ML style, so it was largely a line-by-line port.</p>

<h3 id="previous-rust-experience">Previous Rust experience</h3>

<p>Before this project, I had a small amount of experience with Rust. I was working in an OCaml codebase, and implemented one module in Rust for performance reasons. This was also a case of interoperating between Rust and another programming language.</p>

<p>I didn’t have any experience working with a significant amount of Rust code. However, OCaml is similar to Rust (as Rust descends from OCaml), and I had already read a couple of papers on linear types, so the language didn’t surprise me very much.</p>

<h3 id="why-incremental">Why incremental?</h3>

<p>The small amount of code in the project could conceivably have been rewritten all at once, but I figured it would take a long time to iron out all the bugs that way. I wanted a stable end result, rather than to have to deal with occasional bugs after the initial porting process, so I preferred to use an incremental approach and port the project one module at a time.</p>

<p>By <em>incremental</em>, I’m referring to the method of porting modules individually, rather than all at once. I accomplished this by calling between Rust and Python as appropriate at runtime.</p>

<h2 id="porting">Porting</h2>

<p>The last Python-only version of <code class="language-plaintext highlighter-rouge">git-branchless</code> is <a href="https://github.com/arxanas/git-branchless/releases/tag/v0.1.0">version 0.1.0</a>, and the first Rust-only version is <a href="https://github.com/arxanas/git-branchless/releases/tag/v0.2.0">version 0.2.0</a>. You can browse the 65 commits between these versions to see my progress over time.</p>

<h3 id="strategy">Strategy</h3>

<p>I used the <a href="https://github.com/PyO3/pyo3">PyO3</a> library for Rust to handle the Python-Rust interop. See <a href="https://github.com/arxanas/git-branchless/commit/3020395c96f519c2a70da521d4d20f591582d628">this commit</a> for the initial setup.</p>

<p>PyO3 supports calling Rust from Python and vice-versa:</p>

<ul>
  <li>Call Rust from Python: a step is added to <code class="language-plaintext highlighter-rouge">setup.py</code> which compiles the Rust modules into modules available to Python.</li>
  <li>Call Python from Rust: a specific version of the Python interpreter is linked into the Rust executable, which can be used to execute Python code.</li>
</ul>

<p>I began porting the lowest-level modules individually and worked my way up the dependency hierarchy until I arrived at the main function.</p>

<p>Since git-branchless is implemented as a short-lived script, I didn’t face any significant lifetime-related difficulties in the Rust version. The problematic situations arose when the Python and Rust code both needed to keep a reference to a shared resource. I worked around these issues by copying the resources on the Rust side, and then undid those copies when I deleted the Python code. For example, when passing a database connection from Python to Rust, I opened a new database connection to the same database on the Rust side.</p>

<h3 id="ide-ergonomics">IDE ergonomics</h3>

<p>If you’re using VS Code, do not use the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">official Rust extension (<code class="language-plaintext highlighter-rouge">rust-lang.rust</code>)</a>, as it’s fairly unreliable, and doesn’t offer too many features. Instead use the <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">Rust Analyzer plugin (<code class="language-plaintext highlighter-rouge">matklad.rust-analyzer</code>)</a>, which is more reliable, and offers many quality-of-life features.</p>

<p>The <code class="language-plaintext highlighter-rouge">rust-analyzer</code> IDE experience is refreshingly productive compared to VS Code’s Python offerings.  Some feature highlights:</p>

<ul>
  <li>Autocomplete works reliably, including for symbols not imported into the current scope. In those cases, selecting the autocomplete item also adds a <code class="language-plaintext highlighter-rouge">use</code> statement in the appropriate scope.</li>
  <li>Useful refactorings are suggested routinely. See <a href="https://rust-analyzer.github.io/manual.html#assists-code-actions">the manual</a> for a full list.
    <ul>
      <li>The most common ones I use are “add borrow”/”remove borrow” as appropriate, and “import this missing symbol”. They’re very convenient!</li>
      <li>You can rename symbols, even across multiple modules. If you move or rename a module, it also automatically refactors the module name.</li>
    </ul>
  </li>
  <li>Inline type annotations are shown.
    <ul>
      <li>This is really useful for longer <code class="language-plaintext highlighter-rouge">.iter()</code> method chains to see the inferred types for lambda parameters and results.</li>
      <li>It’s not always obvious when values are borrowed or dereferenced, particularly for a beginner. For example, it’s not necessarily obvious when the fields of a struct are borrowed in a <code class="language-plaintext highlighter-rouge">match</code> statement. Even if you know the types involved, seeing the borrows is still useful.</li>
      <li>It’s also just generally helpful to look at a <code class="language-plaintext highlighter-rouge">let foo = bar();</code> binding and see what the type of <code class="language-plaintext highlighter-rouge">foo</code> is.</li>
    </ul>
  </li>
  <li>Documents are formatted using <code class="language-plaintext highlighter-rouge">rustfmt</code> on save (if you enable the “format-on-save” setting in VS Code). If you’re not using an automatic formatter, then you’re doing yourself a disservice.</li>
</ul>

<p>See <a href="https://rust-analyzer.github.io/manual.html">the manual</a> for a full list.</p>

<h3 id="build-ergonomics">Build ergonomics</h3>

<p>The Rust incremental build times weren’t particularly fast, particularly when using macros from dependencies, as they cannot be compiled ahead of time. Nonetheless, the incremental build time was generally much less than the time it took to run the entire test suite. It was only a problem when selecting only a few tests to run.</p>

<p>On the other hand, the compiler diagnostics, static typing, and IDE support are good enough to write significant amounts of code before having to run a build at all. The typechecker was generally faster than Mypy for Python.</p>

<h3 id="testing-ergonomics">Testing ergonomics</h3>

<p>Rust lets you write unit tests inside the same module as the unit itself, which is particularly convenient when the unit is small enough that you don’t want to expose it to callers. Of course, you can write inline tests in Python too — this is more of an improvement versus other static languages like C++ and Java.</p>

<p>The dynamic nature of Python makes testing easier in general. For example, it’s oftentimes useful to mock out a dependency in a test without having to declare an interface for a dependency and inject it. In similar cases in Rust, I created a <code class="language-plaintext highlighter-rouge">testing</code> sub-module of the modules in question, which exposed the internals of the module to make them more testable.</p>

<p>The default test runner for Rust leaves a lot to be desired compared to <a href="https://docs.pytest.org/en/6.2.x/">Pytest</a>. It’s difficult to ascertain how many tests ran and how many passed, especially when you’ve attempted to filter out some of the tests. The test runner API is <a href="https://github.com/rust-lang/rust/issues/49359">available under a nightly flag</a>, so hopefully we will see some better test runners become available soon.</p>

<h3 id="interop-ergonomics">Interop ergonomics</h3>

<p>The ergonomics of the PyO3 library for Python/Rust interop are great. Interop is <em>safe</em> and <em>composable</em>.</p>

<p><em>Safety</em>: I had no instances of segfaults due to interop. (My only segfault was a stack overflow in Rust-only code, unrelated to interop.) Type mismatches are surfaced as helpful <code class="language-plaintext highlighter-rouge">TypeError</code> exceptions in Python. This was a lot better than the OCaml interop I had to do, where not enough type information is carried at runtime to dynamically check type conversions at the interop boundaries.</p>

<p>PyO3 also uses Rust’s ownership system to ensure that you have a handle to Python’s <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">Global Interpreter Lock (GIL)</a> before doing Python operations. Even if you don’t have concurrency in your project, it ensures you have a handle to a correctly-initialized Python runtime before attempting to do Python operations.</p>

<p><em>Composability</em>: PyO3 makes strong use of Rust’s trait system and coherence rules. If the type system knows how to convert a given set of base types, then it’s easy to teach it how to build an aggregate type consisting of those base types.  This allows for lightweight implicit type conversions between Python types and Rust types, without it being overly difficult to figure out how a type is converted.</p>

<p>These conversions are all <em>fallible</em> as well, so you can fail a type conversion when appropriate, which lets you keep boilerplate error-checking out of the calling code.</p>

<p>After having dealt with OCaml’s overly-powerful module system, I can say that I prefer <a href="https://en.wikipedia.org/wiki/Type_class">typeclasses</a> (Rust traits) for nearly all day-to-day programming. (The typeclass vs module preference is one reason people prefer Haskell over OCaml or vice-versa.)</p>

<h4 id="pyo3s-hello-world">PyO3’s hello world</h4>

<p>To start, let’s take a look at this complete example:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">pyo3</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">PyResult</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Python</span><span class="p">::</span><span class="nf">with_gil</span><span class="p">(|</span><span class="n">py</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">os</span> <span class="o">=</span> <span class="n">py</span><span class="nf">.import</span><span class="p">(</span><span class="s">"os"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">os</span>
            <span class="nf">.call1</span><span class="p">(</span><span class="s">"getenv"</span><span class="p">,</span> <span class="p">(</span><span class="s">"USER"</span><span class="p">,))</span><span class="o">?</span>
            <span class="nf">.extract</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, {}"</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To summarize:</p>

<ol>
  <li>You create an instance of a <code class="language-plaintext highlighter-rouge">Python</code> object using <code class="language-plaintext highlighter-rouge">Python::with_gil</code> or similar.</li>
  <li>You can then access modules, etc., by calling a method like <code class="language-plaintext highlighter-rouge">py.import</code>. Error-checking is handled with the <code class="language-plaintext highlighter-rouge">?</code> operator. It will fail e.g. if the module could not be found.</li>
  <li>To call a method with arguments, use the <code class="language-plaintext highlighter-rouge">call1</code> method with a tuple of arguments. The tuple has to contain values of types which implement the <code class="language-plaintext highlighter-rouge">IntoPy</code> trait, which is already implemented for Rust built-in types. (The <code class="language-plaintext highlighter-rouge">call</code> method works for calls with both positional and keyword arguments; the <code class="language-plaintext highlighter-rouge">call0</code> method works for simple calls without any arguments.) The result is checked with <code class="language-plaintext highlighter-rouge">?</code>. It will fail e.g. if the method threw an exception.</li>
  <li>To convert the result into a Rust type, call <code class="language-plaintext highlighter-rouge">.extract()</code> on it. The result is checked with <code class="language-plaintext highlighter-rouge">?</code>. It will fail e.g. if the Python type could not be converted into the desired Rust type at runtime. In this case, the desired result type is indicated with the <code class="language-plaintext highlighter-rouge">: String</code> type annotation on the <code class="language-plaintext highlighter-rouge">let</code>-binding.</li>
</ol>

<p>It would be difficult to make this simpler and still be statically-checked!</p>

<h4 id="real-example">Real example</h4>

<p>Consider this example of the Python wrapper for the <code class="language-plaintext highlighter-rouge">make_graph</code> function.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[pyfunction]</span>
<span class="k">fn</span> <span class="nf">py_make_graph</span><span class="p">(</span>
    <span class="n">py</span><span class="p">:</span> <span class="n">Python</span><span class="p">,</span>
    <span class="n">repo</span><span class="p">:</span> <span class="n">PyObject</span><span class="p">,</span>
    <span class="n">merge_base_db</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PyMergeBaseDb</span><span class="p">,</span>
    <span class="n">event_replayer</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PyEventReplayer</span><span class="p">,</span>
    <span class="n">head_oid</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">PyOidStr</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">main_branch_oid</span><span class="p">:</span> <span class="n">PyOid</span><span class="p">,</span>
    <span class="n">branch_oids</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">PyOidStr</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">hide_commits</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PyResult</span><span class="o">&lt;</span><span class="n">PyCommitGraph</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">py_repo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">repo</span><span class="p">;</span>
    <span class="k">let</span> <span class="nf">PyRepo</span><span class="p">(</span><span class="n">repo</span><span class="p">)</span> <span class="o">=</span> <span class="n">repo</span><span class="nf">.extract</span><span class="p">(</span><span class="n">py</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">PyMergeBaseDb</span> <span class="p">{</span> <span class="n">merge_base_db</span> <span class="p">}</span> <span class="o">=</span> <span class="n">merge_base_db</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">PyEventReplayer</span> <span class="p">{</span> <span class="n">event_replayer</span> <span class="p">}</span> <span class="o">=</span> <span class="n">event_replayer</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">head_oid</span> <span class="o">=</span> <span class="nf">HeadOid</span><span class="p">(</span><span class="n">head_oid</span><span class="nf">.map</span><span class="p">(|</span><span class="nf">PyOidStr</span><span class="p">(</span><span class="n">oid</span><span class="p">)|</span> <span class="n">oid</span><span class="p">));</span>
    <span class="k">let</span> <span class="nf">PyOid</span><span class="p">(</span><span class="n">main_branch_oid</span><span class="p">)</span> <span class="o">=</span> <span class="n">main_branch_oid</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">main_branch_oid</span> <span class="o">=</span> <span class="nf">MainBranchOid</span><span class="p">(</span><span class="n">main_branch_oid</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">branch_oids</span> <span class="o">=</span> <span class="nf">BranchOids</span><span class="p">(</span><span class="n">branch_oids</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="nf">PyOidStr</span><span class="p">(</span><span class="n">oid</span><span class="p">)|</span> <span class="n">oid</span><span class="p">)</span><span class="nf">.collect</span><span class="p">());</span>
    <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nf">make_graph</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">repo</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">merge_base_db</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">event_replayer</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">head_oid</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">main_branch_oid</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">branch_oids</span><span class="p">,</span>
        <span class="n">hide_commits</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nf">map_err_to_py_err</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">"Could not make graph"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">graph</span><span class="p">:</span> <span class="n">PyResult</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">PyOidStr</span><span class="p">,</span> <span class="n">PyNode</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">oid</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">py_node</span> <span class="o">=</span> <span class="nf">node_to_py_node</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">py_repo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nf">Ok</span><span class="p">((</span><span class="nf">PyOidStr</span><span class="p">(</span><span class="n">oid</span><span class="p">),</span> <span class="n">py_node</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Going over it:</p>

<ol>
  <li>The function is annotated with the <code class="language-plaintext highlighter-rouge">#[pyfunction]</code> macro. This means that any parameters are automatically converted from <code class="language-plaintext highlighter-rouge">PyObject</code>s into the listed types at runtime. It also inserts the <code class="language-plaintext highlighter-rouge">py: Python</code> argument, if your function needs it. The corresponding Python function is registered to be available in a module accessible to Python, not shown here.</li>
  <li>Most argument types are complex types like <code class="language-plaintext highlighter-rouge">PyMergeBaseDb</code> (which wraps the Rust type <code class="language-plaintext highlighter-rouge">MergeBaseDb</code>) or composite types like <code class="language-plaintext highlighter-rouge">HashSet&lt;PyOidStr&gt;</code>.
    <ul>
      <li>You can actually annotate regular Rust types to make them convertible into Python types. I chose to create separate types like <code class="language-plaintext highlighter-rouge">PyMergeBaseDb</code> so that it would be easier to delete them later, without separating out the Python-specific functionality from the Rust functionality.</li>
      <li>The type <code class="language-plaintext highlighter-rouge">PyOidStr</code> is a wrapper type which converts from a Python <code class="language-plaintext highlighter-rouge">str</code> into a Rust <code class="language-plaintext highlighter-rouge">git2::Oid</code>. We can’t use a <code class="language-plaintext highlighter-rouge">String</code> here, because then PyO3 would convert the Python <code class="language-plaintext highlighter-rouge">str</code> into a Rust <code class="language-plaintext highlighter-rouge">String</code>, which is not what we want. So we use a wrapper type to define a non-default type conversion behavior.</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">repo</code> argument is left as a <code class="language-plaintext highlighter-rouge">PyObject</code>, rather than a <code class="language-plaintext highlighter-rouge">PyRepo</code> object, because I call Python methods on it later. I get a <code class="language-plaintext highlighter-rouge">git2::Repository</code> object corresponding to it in the body of the function with the <code class="language-plaintext highlighter-rouge">.extract</code> function.</li>
  <li>I explicitly unpack each wrapped argument in the body of the function. This isn’t strictly necessary, and you can just use e.g. <code class="language-plaintext highlighter-rouge">repo.0</code> if you like, which would make the function body significantly shorter. I did this as a stylistic matter to ensure exhaustiveness-checking.</li>
  <li>The Rust <code class="language-plaintext highlighter-rouge">make_graph</code> function is called with Rust types, and it returns a Rust type.</li>
  <li>The result of <code class="language-plaintext highlighter-rouge">make_graph</code> is checked with <code class="language-plaintext highlighter-rouge">map_err_to_py_err</code>. I’m pretty sure this is unnecessary, and it could have been handled by <code class="language-plaintext highlighter-rouge">?</code>, but I wasn’t familiar enough when I was writing this code.</li>
  <li>We convert the result back into a Python type with <code class="language-plaintext highlighter-rouge">into_iter().map().collect()</code>, and then check the result with <code class="language-plaintext highlighter-rouge">?</code>.</li>
</ol>

<p>I could have made this example even shorter by using more wrapper types (for <code class="language-plaintext highlighter-rouge">head_oid</code>, <code class="language-plaintext highlighter-rouge">main_branch_oid</code>, and <code class="language-plaintext highlighter-rouge">branch_oids</code>) and by not creating intermediate variables.</p>

<h3 id="bugs-encountered">Bugs encountered</h3>

<p>I kept track of a selection of bugs encountered while porting from Python to Rust. Nearly all of them were caught by the regular integration tests. The hardest-to-detect ones involved specification mistranslations, such as changing the meaning of domain entities or setting a configuration flag to the wrong default.</p>

<p>One example of a changed domain entity is that the Python <code class="language-plaintext highlighter-rouge">git2</code> library only allows the construction of valid object IDs (OIDs), while the Rust <code class="language-plaintext highlighter-rouge">git2</code> library allows the construction of arbitrary OIDs. This means that invalid OID errors are detected at different times. I could have wrapped the Rust OID type in a wrapper type which forces me to verify that it exists, but I didn’t bother, and instead relied on tests to expose bugs.</p>

<p>These are my raw notes. They do not accurately capture the frequency of each kind of issue.</p>

<ul>
  <li>Returned OID instead of string from method (immediately caught by tests).</li>
  <li><code class="language-plaintext highlighter-rouge">struct</code> properties not visible from Python (added <code class="language-plaintext highlighter-rouge">#[pyo3(get)]</code>).</li>
  <li>No <code class="language-plaintext highlighter-rouge">==</code> method for <code class="language-plaintext highlighter-rouge">dataclass</code> replacements. Worked around by some minor
rewrites.</li>
  <li>Legitimate regression where we didn’t treat the <code class="language-plaintext highlighter-rouge">0</code> commit hash as a
non-existent old/new ref (partly due to <code class="language-plaintext highlighter-rouge">git2::Oid</code> not verifying that the
OID exists).</li>
  <li>Forgot to implement some methods (immediately revealed by tests).</li>
  <li>Panic due to conversion of -1 to <code class="language-plaintext highlighter-rouge">usize</code> with <code class="language-plaintext highlighter-rouge">try_into().unwrap()</code>; fixed by
delaying conversion until bounds check.</li>
  <li>Legitimate regression: old version of code names were misleading, and I
simplified the ported version into an incorrect version (should have checked
the status of an event at a time in the past, but instead checked the current
status). Detected by tests.</li>
  <li>Double bug: name mixup for two string fields in Rust; and off-by-one error
when translating reverse iteration in Python to Rust.</li>
  <li><code class="language-plaintext highlighter-rouge">TypeError: argument 'main_branch_oid': 'Oid' object cannot be converted to 'PyString'</code> (immediately caught by tests). Legitimate type mismatch
between Python and Rust type signatures.</li>
  <li>TypeError: accidentally wrote list of bytes to TextIO instead of str.</li>
  <li>Defaulted a configuration setting to <code class="language-plaintext highlighter-rouge">false</code> instead of <code class="language-plaintext highlighter-rouge">true</code>, causing
test failures.</li>
  <li>Several bugs which reproduced only in CI builds, but not on my local machine. Generally, they were due to passing the wrong environment variables around, which caused them to load the wrong dynamically-linked Rust modules (<code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code>) or invoke the wrong version of Git (<code class="language-plaintext highlighter-rouge">PATH</code>).</li>
</ul>

<p>I filed three issues against Rust libraries that I used:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rustfmt</code>: <a href="https://github.com/rust-lang/rustfmt/issues/4624">https://github.com/rust-lang/rustfmt/issues/4624</a></li>
  <li><code class="language-plaintext highlighter-rouge">cursive</code>: <a href="https://github.com/gyscos/cursive/issues/563">https://github.com/gyscos/cursive/issues/563</a></li>
  <li><code class="language-plaintext highlighter-rouge">pyo3</code>: <a href="https://github.com/PyO3/pyo3/issues/1490">https://github.com/PyO3/pyo3/issues/1490</a></li>
</ul>

<h2 id="results">Results</h2>

<h3 id="porting-time">Porting time</h3>

<p>I was generally able to port a given module and its tests in one or two days. However, I worked on this over a long period of time as it’s not part of my day job, so it took a a few months to finish the port (from December 18, 2020 to March 15, 2021).</p>

<p>The Python code was already written in an ML style, with use of algebraic data types and very limited metaprogramming. If you can statically check your code with Mypy, then it will probably be relatively easy to port it to Rust. But if it uses dynamic runtime features, you should expect it to be more difficult.</p>

<h3 id="lines-of-code">Lines of code</h3>

<p>I used <a href="https://github.com/AlDanial/cloc"><code class="language-plaintext highlighter-rouge">cloc</code></a> to perform line counts.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Language</th>
      <th style="text-align: left">Type</th>
      <th style="text-align: left">Files</th>
      <th style="text-align: left">Blank</th>
      <th style="text-align: left">Comment</th>
      <th style="text-align: left">Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Python</td>
      <td style="text-align: left">Source code</td>
      <td style="text-align: left">16</td>
      <td style="text-align: left">614</td>
      <td style="text-align: left">849</td>
      <td style="text-align: left">2481</td>
    </tr>
    <tr>
      <td style="text-align: left">Python</td>
      <td style="text-align: left">Test code</td>
      <td style="text-align: left">14</td>
      <td style="text-align: left">295</td>
      <td style="text-align: left">535</td>
      <td style="text-align: left">1308</td>
    </tr>
    <tr>
      <td style="text-align: left">Python</td>
      <td style="text-align: left">Total</td>
      <td style="text-align: left">30</td>
      <td style="text-align: left">909</td>
      <td style="text-align: left">1384</td>
      <td style="text-align: left">3789</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Source code</td>
      <td style="text-align: left">18</td>
      <td style="text-align: left">531</td>
      <td style="text-align: left">835</td>
      <td style="text-align: left">4186</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Source noise</td>
      <td style="text-align: left">18</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">644</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Test code</td>
      <td style="text-align: left">9</td>
      <td style="text-align: left">217</td>
      <td style="text-align: left">11</td>
      <td style="text-align: left">1642</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Test noise</td>
      <td style="text-align: left">9</td>
      <td style="text-align: left"> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">277</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Total</td>
      <td style="text-align: left">27</td>
      <td style="text-align: left">748</td>
      <td style="text-align: left">846</td>
      <td style="text-align: left">5828</td>
    </tr>
    <tr>
      <td style="text-align: left">Rust</td>
      <td style="text-align: left">Total minus noise</td>
      <td style="text-align: left">27</td>
      <td style="text-align: left">748</td>
      <td style="text-align: left">846</td>
      <td style="text-align: left">4907</td>
    </tr>
  </tbody>
</table>

<p>The Rust version has significantly more lines of code. A portion of that can be attributed to “line noise” (lines which only consist of whitespace and closing delimiters). I calculated the amount of line noise with this command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find &lt;dir&gt; -name '*.rs' -exec egrep '^[ });,]+$' {} \; | wc -l
</code></pre></div></div>

<p>The rest is probably due to more verbose idioms, such as the following:</p>

<ul>
  <li>Chained iterator functions rather than list comprehensions.</li>
  <li>Can’t use <code class="language-plaintext highlighter-rouge">let seq = if cond { vec.iter() } else  { vec.iter().rev() }</code>; you have to use a helper function or write the code twice.
    <ul>
      <li>Ideally, you would be able to write something like <code class="language-plaintext highlighter-rouge">let seq: impl Iterator&lt;Item = Foo&gt; = { ... };</code>, although this probably has significant compiler difficulties.</li>
    </ul>
  </li>
  <li>Generators are not yet supported in stable Rust, so I had to rewrite one case of a breadth-first search to use callbacks instead.</li>
</ul>

<p>Despite this, I feel that Rust is nearly as expressive as Python, particularly compared to a language like C++.</p>

<h3 id="time-comparison">Time comparison</h3>

<p>It’s hard to compare the speedup between Python and Rust, as I didn’t have any end-to-end benchmarks set up.</p>

<p>I took the following measurements for running the test suites serially. Unfortunately, it’s not very meaningful, because the majority of the time is spent shelling out to Git to set up the test repository.</p>

<ul>
  <li>Python: ~50 seconds.</li>
  <li>Rust: ~20 seconds.</li>
</ul>

<p>The specific case of Git hooks taking too long to run was considerably improved. I initiated a rebase of a stack of 20 commits with the Python and Rust versions. The Python version got through only a couple of commits in 10 seconds or so before I cancelled it, whereas the Rust version finished rebasing all the commits in a few seconds. So the particular use-case I was optimizing for was greatly improved.</p>

<h2 id="conclusions">Conclusions</h2>

<p>In summary:</p>

<ul>
  <li>The static typing and IDE support is better for Rust compared to Python.</li>
  <li>The build and testing workflow is worse for Rust compared to Python.</li>
  <li>The performance is greatly improved for Rust compared to Python, but I didn’t measure it in a quantitative way.</li>
  <li>Incremental porting with PyO3 was quite reasonable for this small project.
    <ul>
      <li>It would presumably be more difficult with a larger project which has more nuanced runtime resource management.</li>
      <li>For “hub-and-spoke” projects, which don’t have deep dependency trees, an incremental approach is likely tractable.</li>
    </ul>
  </li>
</ul>

<h2 id="related-posts">Related posts</h2>

<p>The following are hand-curated posts which you might find interesting.</p>

<table class="related-posts">
<thead>
  <tr>
    <th>Date</th>
    <th></th>
    <th>Title</th>
  </tr>
</thead>

<tbody>

  <tr>
    <td>03&nbsp;Jan&nbsp;2021</td>
    <td class="this-post">
      
      </td>
    <td><a href="/rust-modules-for-python-users/">The Rust module system for Python users</a>
    </td>
  </tr>

  <tr>
    <td>29&nbsp;Apr&nbsp;2021</td>
    <td class="this-post">
      
      (this&nbsp;post)
      
      </td>
    <td><a href="/port-python-to-rust/">Incrementally porting a small Python project to Rust</a>
    </td>
  </tr>

</tbody>
</table>

<p>Want to see more of my posts? Follow me <a href="https://twitter.com/arxanas">on Twitter</a> or subscribe <a href="/feed.xml">via RSS</a>.</p>

<h2 id="comments">Comments</h2>

<ul>



</ul>

<script type="text/javascript" src="/scripts/github-comment-links.js"></script>

<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://blog.waleedkhan.name/port-python-to-rust/";
    this.page.identifier = "port-python-to-rust/";
};

(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//waleedkhan-name.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Steno & PL</h2>
    
    <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Waleed Khan</li>
          <li><a href="mailto:me@waleedkhan.name">me@waleedkhan.name</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/arxanas"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/arxanas"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">arxanas</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>This is a personal blog. Unless otherwise stated, the opinions
expressed here are my own, and not those of my past or present
employers.</p>
      </div>
    </div>

  </div>

  
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-53066274-1', 'auto');
ga('send', 'pageview');
</script>



</footer>


  </body>

</html>
